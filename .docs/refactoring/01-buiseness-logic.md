# Рефакторинг бизнес-логики

Этот документ описывает первый итеративный шаг рефакторинга в рамках **Этапа 3** плана проекта. Изменения коснулись только тех классов, которые были покрыты Unit-тестами на предыдущем этапе.

## 1. Проблема

Отчеты статических анализаторов (Checkstyle и PMD) выявили ряд проблем в классах, покрытых тестами:

*   **Нарушение инкапсуляции во ViewModel:** Поля `MutableLiveData` были объявлены как `public`. Это позволяло любому внешнему классу (например, фрагменту) напрямую изменять состояние `ViewModel`, что нарушает архитектурный принцип "Single Source of Truth" и делает поведение приложения непредсказуемым.

*   **"Магические числа":** В `ProductCatalogViewModel` использовалось число `100` без какого-либо объяснения его назначения, что ухудшало читаемость кода.

*   **Нарушение стиля кода:** В классе `Methods` использовалась переменная `ST`, что не соответствует Java Naming Conventions для локальных переменных.

## 2. Проведенные изменения

Для устранения этих проблем был выполнен следующий рефакторинг:

1.  **Инкапсуляция `LiveData`:**
    *   Во всех протестированных `ViewModel` (`ProductCatalogViewModel`, `SplashViewModel`, `ProductDetailViewModel`) поля `MutableLiveData` были сделалены `private`.
    *   Для них были созданы публичные `getter`'ы, возвращающие неизменяемый `LiveData`. Это позволяет UI-слою подписываться на данные, но не изменять их.

2.  **Улучшение читаемости кода:**
    *   В `ProductCatalogViewModel` "магическое число" `100` было заменено на именованную константу `MAX_RANDOM_PRICE`.
    *   В классе `Methods` локальная переменная `ST` была переименована в `st`.

3.  **Обновление кода:**
    *   UI-слой (`Fragments`, `Activities`) и Unit-тесты были обновлены для работы с новыми `getter`'ами `LiveData`.

## 3. Результат

*   **Повышение надежности:** Состояние `ViewModel` теперь может быть изменено только изнутри самой `ViewModel`. Это делает поток данных однонаправленным и предсказуемым.
*   **Соответствие стандартам:** Код стал более профессиональным и понятным для любого Java-разработчика.

Этот рефакторинг является важным шагом к повышению общего качества кодовой базы и был проведен под защитой ранее написанных Unit-тестов, которые подтвердили, что функциональность приложения не была нарушена.

---

## Итерация 2: Надежность и производительность

### 1. Проблема

Повторный анализ отчетов PMD и Checkstyle выявил следующие проблемы в коде, покрытом тестами:

*   **Риск `NullPointerException`:** Метод `Methods.isEqual()` использовал небезопасное сравнение `str1.equals(str2)`, которое приводило бы к падению приложения, если `str1` равен `null`.
*   **Неэффективное создание объектов:** В `ProductCatalogViewModel.generateVisualChanges()` объект `Random` создавался заново на каждой итерации цикла, что является избыточным и снижает производительность.
*   **"Магические строки":** В том же методе использовался жестко закодированный строковый литерал `"Sauce Labs Onesie"`, что делает код хрупким к изменениям в данных.

### 2. Проведенные изменения

1.  **Повышение надежности `Methods.isEqual()`:** Небезопасное сравнение было заменено на `java.util.Objects.equals(str1, str2)`, который корректно обрабатывает `null`-значения.
2.  **Оптимизация `generateVisualChanges()`:** Создание объекта `Random` было вынесено за пределы цикла.
3.  **Устранение "магической строки":** Строка `"Sauce Labs Onesie"` была вынесена в `private static final` константу.

### 3. Результат

*   **Повышение надежности:** Устранен потенциальный источник `NullPointerException`.
*   **Оптимизация производительности:** Сокращено количество создаваемых объектов в цикле.
*   **Улучшение поддерживаемости:** Код стал более читаемым и менее подверженным ошибкам при изменении данных.

---

## Итерация 3: Упрощение логики и повышение надежности

### 1. Проблема

Финальный анализ выявил следующие моменты:

*   **Избыточная сложность:** Длинная `if-else if` цепочка в `ProductCatalogViewModel` для выбора типа сортировки ухудшала читаемость.
*   **Неявная зависимость:** Метод `getAllProducts(int type)` игнорировал свой параметр `type` и вместо этого использовал глобальную статическую переменную, что делало его поведение неочевидным.
*   **Риск `NumberFormatException`:** В `ProductDetailViewModel` отсутствовала обработка ошибки на случай, если переданный `id` не может быть преобразован в число.

### 2. Проведенные изменения

1.  **Рефакторинг сортировки:** Конструкция `if-else if` была заменена на более лаконичный и читаемый `switch`.
2.  **Устранение неявной зависимости:** Метод `getAllProducts` был исправлен, чтобы использовать переданный ему параметр `type`, что делает его самодостаточным.
3.  **Обработка ошибок:** В `ProductDetailViewModel` добавлен блок `try-catch` для безопасного парсинга `id`.

## Итоги Этапа 3: Рефакторинг бизнес-логики

За три итерации рефакторинга мы успешно устранили наиболее критичные проблемы, обнаруженные статическими анализаторами в коде, покрытом тестами.

**Ключевые результаты:**
*   **Улучшена архитектура:** Внедрена инкапсуляция для `LiveData`, что сделало поток данных предсказуемым.
*   **Повышена надежность:** Устранены потенциальные `NullPointerException` и `NumberFormatException`.
*   **Оптимизирована производительность:** Убрано избыточное создание объектов в циклах.
*   **Улучшена читаемость:** Код избавлен от "магических чисел" и строк, а сложные логические конструкции были упрощены.

Все изменения проводились под защитой Unit-тестов, что гарантировало сохранение работоспособности приложения. Этап рефакторинга бизнес-логики можно считать успешно завершенным.
