# Статический анализ с PMD

## 1. Для чего нужен PMD?

**PMD** — это мощный статический анализатор исходного кода. В отличие от **Checkstyle**, который фокусируется на *стиле* кода (отступы, скобки, именование), PMD ищет более глубокие проблемы и потенциальные ошибки в логике.

Его можно представить как опытного наставника, который просматривает ваш код и указывает на "дурно пахнущие" участки (code smells), которые могут привести к багам, проблемам с производительностью или уязвимостям в будущем.

**Ключевые цели PMD:**
*   **Повышение надежности:** Находит код, склонный к ошибкам (например, пустые `catch` блоки).
*   **Улучшение производительности:** Обнаруживает неэффективные конструкции (например, создание объектов в цикле).
*   **Повышение безопасности:** Указывает на потенциальные уязвимости.
*   **Упрощение поддержки:** Помогает бороться со слишком сложным и запутанным кодом.

## 2. Какие проверки он выполняет?

PMD группирует свои правила в наборы (rulesets). В нашем проекте (`config/pmd/pmd.xml`) мы используем несколько стандартных наборов, которые покрывают основные аспекты качества кода:

| Категория | Описание и примеры проверок |
| :--- | :--- |
| **Best Practices** | Правила, помогающие избежать распространенных ошибок и следовать лучшим практикам. <br> - `UnusedPrivateMethod`: Неиспользуемый приватный метод. <br> - `EmptyCatchBlock`: Пустой блок `catch`, который "проглатывает" исключения. <br> - `SystemPrintln`: Использование `System.out.println` вместо логгера. |
| **Code Style** | Правила, связанные со стилем, но выходящие за рамки простого форматирования. <br> - `UselessParentheses`: Лишние скобки в выражениях. <br> - `UnnecessaryModifier`: Избыточные модификаторы (например, `public` в методе интерфейса). <br> - `EmptyMethodInAbstractClass`: Пустой метод в абстрактном классе, который следовало бы сделать абстрактным. |
| **Design** | Правила, указывающие на проблемы в дизайне и архитектуре кода. <br> - `CyclomaticComplexity`: Слишком высокая цикломатическая сложность метода (много `if`, `for`, `while`), что делает его трудным для понимания и тестирования. <br> - `GodClass`: Класс, который делает слишком много и нарушает принцип единственной ответственности. <br> - `TooManyMethods`: Класс со слишком большим количеством методов. |
| **Error Prone** | Правила, которые выявляют код, с высокой вероятностью содержащий ошибки. <br> - `EmptyTryBlock`: Пустой блок `try`. <br> - `NullAssignment`: Присваивание `null` переменной, что часто является плохой практикой. <br> - `AvoidBranchingStatementAsLastInLoop`: Использование `break` или `continue` как последнего оператора в цикле. |
| **Performance** | Правила, помогающие найти неэффективный код. <br> - `AvoidInstantiatingObjectsInLoops`: Создание новых объектов внутри цикла. <br> - `UseStringBufferForStringAppends`: Использование `+` для конкатенации строк в цикле вместо `StringBuilder`. |
| **Security** | Правила, выявляющие потенциальные уязвимости в коде. <br> - `HardcodedCryptoKey`: Жестко закодированные криптографические ключи. <br> - `InsecureRandomNumberGenerator`: Использование `java.util.Random` вместо более безопасного `java.security.SecureRandom`. |

## 3. Настройка для Android

Настройка PMD в Android-проекте имеет свои особенности из-за системы вариантов сборки (`build variants`). Вот как это реализовано в нашем проекте:

1.  **Подключение плагина:** В файле `app/build.gradle` подключается плагин PMD:
    ```groovy
    apply plugin: 'pmd'
    ```

2.  **Файл конфигурации правил:** Все правила, которые должен проверять PMD, описаны в файле `config/pmd/pmd.xml`.

3.  **Скрипт настройки Gradle:** Чтобы не загромождать основной `app/build.gradle`, вся логика настройки вынесена в отдельный файл `gradle/pmd.gradle` и применяется через:
    ```groovy
    apply from: "$project.rootDir/gradle/pmd.gradle"
    ```

4.  **Интеграция в жизненный цикл сборки:** Внутри `gradle/pmd.gradle` используется специальный блок, который автоматически создает задачу PMD для каждого варианта сборки (`debug`, `release` и т.д.) и "подключает" ее к стандартной задаче `check`.
    ```groovy
    android.applicationVariants.all { variant ->
        tasks.register("pmd${variant.name.capitalize()}", Pmd) {
            // ... настройки ...
        }
    }
        tasks.named('check').configure {
        dependsOn tasks.withType(Pmd)
    }
    ```
    Это позволяет запускать анализ двумя способами:
    *   **Для конкретной сборки:**
        ```shell
        ./gradlew app:pmdDebug
        ```
    *   **Вместе со всеми остальными проверками** (юнит-тесты, Checkstyle):
        ```shell
        ./gradlew app:check
        ```

5.  **Ключевые параметры настройки:**
    *   `source = variant.javaCompileProvider.get().source`: Указывает PMD, где находятся исходные файлы для конкретного варианта сборки. Это самая важная часть для корректной работы с Android.
    *   `ruleSetFiles`: Указывает путь к нашему файлу с правилами.
    *   `ignoreFailures = true`: **Очень важный параметр на начальном этапе.** Он позволяет пайплайну не падать, даже если PMD нашел нарушения. При этом отчет все равно будет сгенерирован. Это дает команде возможность видеть технический долг, не блокируя разработку.

Таким образом, PMD интегрирован в проект как инструмент для глубокого анализа кода, который генерирует отчеты о потенциальных проблемах, но на данном этапе не блокирует CI/CD, позволяя постепенно исправлять найденные нарушения.
