# Статический анализ с PMD

## 1. Для чего нужен PMD?

**PMD** — это мощный статический анализатор исходного кода. В отличие от **Checkstyle**, который фокусируется на *стиле* кода (отступы, скобки, именование), PMD ищет более глубокие проблемы и потенциальные ошибки в логике.

Его можно представить как опытного наставника, который просматривает ваш код и указывает на "дурно пахнущие" участки (code smells), которые могут привести к багам, проблемам с производительностью или уязвимостям в будущем.

**Ключевые цели PMD:**
*   **Повышение надежности:** Находит код, склонный к ошибкам (например, пустые `catch` блоки).
*   **Улучшение производительности:** Обнаруживает неэффективные конструкции (например, создание объектов в цикле).
*   **Повышение безопасности:** Указывает на потенциальные уязвимости.
*   **Упрощение поддержки:** Помогает бороться со слишком сложным и запутанным кодом.

## 2. Какие проверки он выполняет?

PMD группирует свои правила в наборы (rulesets). В нашем проекте (`config/pmd/pmd.xml`) мы используем несколько стандартных наборов, которые покрывают основные аспекты качества кода:

| Категория | Описание и примеры проверок |
| :--- | :--- |
| **Best Practices** | Правила, помогающие избежать распространенных ошибок и следовать лучшим практикам. <br> - `UnusedPrivateMethod`: Неиспользуемый приватный метод. <br> - `EmptyCatchBlock`: Пустой блок `catch`, который "проглатывает" исключения. <br> - `SystemPrintln`: Использование `System.out.println` вместо логгера. |
| **Code Style** | Правила, связанные со стилем, но выходящие за рамки простого форматирования. <br> - `UselessParentheses`: Лишние скобки в выражениях. <br> - `UnnecessaryModifier`: Избыточные модификаторы (например, `public` в методе интерфейса). <br> - `EmptyMethodInAbstractClass`: Пустой метод в абстрактном классе, который следовало бы сделать абстрактным. |
| **Design** | Правила, указывающие на проблемы в дизайне и архитектуре кода. <br> - `CyclomaticComplexity`: Слишком высокая цикломатическая сложность метода (много `if`, `for`, `while`), что делает его трудным для понимания и тестирования. <br> - `GodClass`: Класс, который делает слишком много и нарушает принцип единственной ответственности. <br> - `TooManyMethods`: Класс со слишком большим количеством методов. |
| **Error Prone** | Правила, которые выявляют код, с высокой вероятностью содержащий ошибки. <br> - `EmptyTryBlock`: Пустой блок `try`. <br> - `NullAssignment`: Присваивание `null` переменной, что часто является плохой практикой. <br> - `AvoidBranchingStatementAsLastInLoop`: Использование `break` или `continue` как последнего оператора в цикле. |
| **Performance** | Правила, помогающие найти неэффективный код. <br> - `AvoidInstantiatingObjectsInLoops`: Создание новых объектов внутри цикла. <br> - `UseStringBufferForStringAppends`: Использование `+` для конкатенации строк в цикле вместо `StringBuilder`. |
| **Security** | Правила, выявляющие потенциальные уязвимости в коде. <br> - `HardcodedCryptoKey`: Жестко закодированные криптографические ключи. <br> - `InsecureRandomNumberGenerator`: Использование `java.util.Random` вместо более безопасного `java.security.SecureRandom`. |

## 3. Настройка для Android

Настройка PMD в Android-проекте имеет свои особенности из-за системы вариантов сборки (`build variants`) и генерации кода.

### 3.1. Модульная конфигурация

Чтобы не загромождать основной файл `app/build.gradle`, вся логика настройки вынесена в отдельный скрипт `gradle/pmd.gradle`. Он подключается одной строкой:

```groovy
// app/build.gradle
apply from: "$project.rootDir/gradle/pmd.gradle"
```

В самом скрипте `gradle/pmd.gradle` применяется плагин и настраиваются общие параметры:

```groovy
// gradle/pmd.gradle
apply plugin: 'pmd'

// Общие настройки можно вынести сюда, если они есть
```

### 3.2. Интеграция с вариантами сборки Android

Ключевая сложность — заставить PMD анализировать исходники для каждого варианта сборки (`debug`, `release`) и при этом игнорировать автоматически сгенерированный код.

Эта проблема решается путем динамического создания задач для каждого варианта:

```groovy
// gradle/pmd.gradle
android.applicationVariants.all { variant ->
    tasks.register("pmd${variant.name.capitalize()}", Pmd) {
        description = "Run PMD analysis for the ${variant.name} build."
        group = "verification"

        // Указываем исходники для анализа
        source = variant.javaCompileProvider.get().source

        // Файл с правилами
        ruleSetFiles = files("${project.rootDir}/config/pmd.xml")
        ignoreFailures = true // Не ронять сборку при ошибках

        // Настройка отчетов
        reports {
            xml.required = true
            html.required = true
        }
    }
}
```

### 3.3. Возможные проблемы и их решение

**Проблема №1: PMD анализирует сгенерированный код.**
*   **Симптомы:** В отчетах PMD появляется множество нарушений (например, `MethodArgumentCouldBeFinal`, `FieldNamingConventions`) для файлов, находящихся в директории `app/build/generated`. Это "шум", который мешает находить реальные проблемы в коде проекта.
*   **Причина:** По умолчанию PMD анализирует все файлы, которые предоставляет `variant.javaCompileProvider.get().source`, включая сгенерированные классы Data Binding.
*   **Решение:** Необходимо явно исключить сгенерированные файлы из анализа. Это можно сделать, добавив блок `exclude` в конфигурацию задачи:
    ```groovy
    // gradle/pmd.gradle
    tasks.register("pmd...", Pmd) {
        // ...
        exclude '**/databinding/*Binding.java'
        exclude '**/generated/data_binding_base_class_source_out/**'
        // ...
    }
    ```
    Это позволит сфокусироваться на качестве кода, написанного вручную.

**Проблема №2: Несовместимость с Gradle Configuration Cache.**
*   **Симптомы:** При включенном Configuration Cache сборка может падать с ошибкой, связанной с вычислением `source` на этапе конфигурации.
*   **Причина:** Текущая реализация использует вызов `.get()` на `Provider` (`variant.javaCompileProvider.get()`). Это заставляет Gradle вычислять значение на этапе конфигурации, что несовместимо с механизмом кеширования.
*   **Решение (на будущее):** Для полной совместимости следует использовать "ленивые" API Gradle, передавая `Provider` напрямую в свойство `source`, чтобы отложить вычисление значения до этапа выполнения.

**Проблема №3: Ошибки SSL-сертификатов при загрузке.**
*   **Симптомы:** При первой сборке Gradle не может загрузить сам плагин PMD или его зависимости, завершаясь с ошибкой `PKIX path building failed`.
*   **Причина:** Эта ошибка обычно возникает, когда сборка происходит в корпоративной сети с прокси-сервером. JVM, на которой работает Gradle, не доверяет этим сертификатам.
*   **Решение:** Необходимо добавить корневой сертификат сети в хранилище доверенных сертификатов (`cacerts`) той версии JDK, которую использует Gradle. Подробное описание этой проблемы и ее решение задокументировано в файле link:../troubles/setup_issues.md[Проблемы при настройке проекта].