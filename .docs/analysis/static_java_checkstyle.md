# Статический анализ с Checkstyle

## 1. Для чего нужен Checkstyle?

**Checkstyle** — это статический анализатор, который помогает разработчикам придерживаться единого стиля кодирования. В отличие от **PMD**, который ищет потенциальные ошибки и "запахи" в коде, Checkstyle фокусируется исключительно на *внешнем виде* и *форматировании* кода.

Его можно представить как "полицию стиля", которая следит за тем, чтобы код, написанный разными людьми, выглядел единообразно.

**Ключевые цели Checkstyle:**
*   **Единообразие кода:** Гарантирует, что все следуют общим правилам именования, расстановки скобок, отступов и т.д.
*   **Повышение читаемости:** Чистый и отформатированный код легче читать и понимать.
*   **Автоматизация рутины:** Избавляет от необходимости вручную форматировать код и спорить о стилях на код-ревью.

## 2. Какие проверки он выполняет?

Файл конфигурации `config/checkstyle/checkstyle.xml` основан на **Google Java Style Guide** и включает в себя множество проверок, сгруппированных по категориям.

| Категория | Описание и примеры проверок |
| :--- | :--- |
| **Именование (Naming)** | Следит за соблюдением стандартов именования для всех элементов кода. <br> - `PackageName`: Имена пакетов в нижнем регистре. <br> - `TypeName`: Имена классов и интерфейсов в `PascalCase`. <br> - `MethodName`, `MemberName`, `ParameterName`: Имена методов, полей и параметров в `camelCase`. |
| **Импорты (Imports)** | Организует блок импортов, делая его чистым и предсказуемым. <br> - `AvoidStarImport`: Запрещает "звездочные" импорты (например, `import java.util.*`). <br> - `UnusedImports`: Находит и требует удалить неиспользуемые импорты. <br> - `ImportOrder`: Обеспечивает строгий порядок групп импортов (`java`, `javax`, `org`, `com`, `by`). |
| **Блоки и отступы (Blocks & Whitespace)** | Обеспечирует единообразное визуальное форматирование кода. <br> - `NeedBraces`: Требует использовать фигурные скобки `{}` для всех блоков `if`, `else`, `for`, `while`. <br> - `WhitespaceAround`: Контролирует наличие пробелов вокруг операторов (`=`, `+`, `if` и т.д.). <br> - `FileTabCharacter`: Запрещает использование символов табуляции, разрешая только пробелы. |
| **Размеры (Sizing)** | Помогает сохранять код компактным и читаемым. <br> - `LineLength`: Ограничивает максимальную длину строки (в проекте — 120 символов), чтобы избежать горизонтальной прокрутки. |
| **Распространенные ошибки (Coding)** | Находит конструкции, которые могут приводить к ошибкам или являются плохой практикой. <br> - `MissingSwitchDefault`: Требует наличия `default` в `switch`. <br> - `EqualsHashCode`: Гарантирует, что если переопределен метод `equals()`, то должен быть переопределен и `hashCode()`. <br> - `FinalClass`: Требует, чтобы классы, содержащие только `private` конструкторы, были объявлены как `final`. |

## 3. Настройка для Android

Настройка Checkstyle в Android-проекте имеет свои особенности из-за системы вариантов сборки (`build variants`). Вот как это реализовано в нашем проекте для обеспечения корректной и гибкой работы.

### 3.1. Модульная конфигурация

Чтобы не загромождать основной файл `app/build.gradle`, вся логика настройки вынесена в отдельный скрипт `gradle/checkstyle.gradle`. Он подключается одной строкой:

```groovy
// app/build.gradle
apply from: "$project.rootDir/gradle/checkstyle.gradle"
```

В самом скрипте `gradle/checkstyle.gradle` применяется плагин и указывается его версия:

```groovy
// gradle/checkstyle.gradle
apply plugin: 'checkstyle'

checkstyle {
    toolVersion = "10.16.0" // Явное указание версии для консистентности сборок
}
```

### 3.2. Интеграция с вариантами сборки Android

Ключевая сложность в Android — наличие разных вариантов сборки (`debug`, `release` и т.д.), у каждого из которых свой набор исходных кодов. Checkstyle должен анализировать правильные файлы для каждого варианта.

Эта проблема решается путем динамического создания задач для каждого варианта:

```groovy
// gradle/checkstyle.gradle
android.applicationVariants.all { variant ->
    def variantName = variant.name
    def capitalizedVariantName = variantName.capitalize()

    tasks.register("checkstyle${capitalizedVariantName}", Checkstyle) {
        description = "Run Checkstyle analysis for the ${variantName} build."
        group = "verification"

        // Указываем исходники для анализа
        source = variant.sourceSets.java.srcDirs

        // Указываем classpath для разрешения типов
        classpath = files(variant.javaCompileProvider.get().classpath)

        // Файл с правилами
        configFile = file("${project.rootDir}/config/checkstyle.xml")
        ignoreFailures = true // Не ронять сборку при ошибках

        // Настройка отчетов
        reports {
            xml.required = true
            html.required = true
        }
    }
}
```

### 3.3. Возможные проблемы и их решение

При настройке Checkstyle в Android-проекте можно столкнуться с несколькими типичными проблемами.

**Проблема №1: Checkstyle не видит классы проекта.**
*   **Симптомы:** Анализ падает с ошибками на правилах, требующих информации о типах (например, `EqualsHashCode`, `IllegalImport`), хотя сам проект успешно компилируется.
*   **Причина:** По умолчанию задача Checkstyle не знает о зависимостях проекта и не может разрешить типы, которые используются в коде.
*   **Решение:** Необходимо явно передать в задачу `classpath` (путь к скомпилированным классам и зависимостям) для соответствующего варианта сборки. В нашей конфигурации это делается строкой:
    ```groovy
    classpath = files(variant.javaCompileProvider.get().classpath)
    ```

**Проблема №2: Несовместимость с Gradle Configuration Cache.**
*   **Симптомы:** При включенном Configuration Cache сборка может падать с ошибкой `property 'classpath' doesn't have a configured value`.
*   **Причина:** Текущая реализация использует вызов `.get()` на `Provider` (`variant.javaCompileProvider.get()`). Это заставляет Gradle вычислять значение `classpath` на этапе конфигурации, что несовместимо с механизмом кеширования конфигурации.
*   **Решение (на будущее):** Для полной совместимости следует использовать "ленивые" API Gradle, передавая `Provider` напрямую в свойство задачи, если оно это поддерживает, чтобы отложить вычисление значения до этапа выполнения.

**Проблема №3: Ошибки SSL-сертификатов при загрузке.**
*   **Симптомы:** При первой сборке Gradle не может загрузить сам плагин Checkstyle или его зависимости, завершаясь с ошибкой `PKIX path building failed`.
*   **Причина:** Эта ошибка обычно возникает, когда сборка происходит в корпоративной сети с прокси-сервером, который подменяет SSL-сертификаты. JVM, на которой работает Gradle, не доверяет этим сертификатам по умолчанию.
*   **Решение:** Необходимо добавить корневой сертификат вашей корпоративной сети в хранилище доверенных сертификатов (`cacerts`) той версии JDK, которую использует Gradle. Подробное описание этой проблемы и ее решение задокументировано в файле link:../troubles/setup_issues.md[Проблемы при настройке проекта].


**Проблема**

При попытке собрать проект Gradle не мог загрузить зависимости из удаленных репозиториев (Maven Central, JitPack и т.д.), завершаясь с ошибкой, связанной с SSL/TLS:
```
Could not resolve all files for configuration ':classpath'.
> Could not resolve com.android.tools.build:gradle:8.9.2.
  ...
  > Could not get resource 'https://repo.maven.apache.org/maven2/...'.
    > Could not GET '...'.
      > PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target
```
Эта ошибка обычно возникает, когда сборка происходит в корпоративной сети с прокси-сервером, который подменяет SSL-сертификаты. JVM, на которой работает Gradle, не доверяет этим сертификатам по умолчанию.

**Решение**

Решение заключается в том, чтобы добавить корневой сертификат корпоративной сети в хранилище доверенных сертификатов (`cacerts`) той версии JDK, которую использует Gradle.

1.  **Получить файл сертификата.** Необходимо получить корневой сертификат сети (например, в формате `.cer` или `.pem`). Обычно его можно экспортировать из браузера или запросить у системного администратора.

2.  **Определить путь к JDK.** Найти директорию установки JDK, используемой для сборки.

3.  **Импортировать сертификат.** Использовать утилиту `keytool`, которая поставляется вместе с JDK, для импорта сертификата в хранилище `cacerts`.

    Пример команды для macOS или Linux:
    ```shell
    keytool -import -trustcacerts \
            -keystore "$JAVA_HOME/lib/security/cacerts" \
            -storepass changeit \
            -noprompt \
            -alias "my-corp-root-ca" \
            -file "/path/to/your/corporate-root.cer"
    ```
    *   `-keystore`: Путь к файлу `cacerts` вашего JDK.
    *   `-storepass`: Пароль по умолчанию для `cacerts` — `changeit`.
    *   `-alias`: Уникальное имя (псевдоним) для вашего сертификата в хранилище.
    *   `-file`: Путь к файлу вашего сертификата.

После импорта сертификата JVM сможет устанавливать доверенные HTTPS-соединения, и Gradle успешно загрузит все зависимости.
