= Работа с монорепозиториями: организация и лучшие практики

В то время как большинство проектов используют подход "один проект — один репозиторий" (polyrepo), существует и альтернативная стратегия — монорепозиторий. Крупные компании, такие как Google, Meta и Microsoft, успешно используют ее для управления огромной кодовой базой.

== Что такое монорепозиторий?

*Монорепозиторий* — это единый Git-репозиторий, в котором хранится исходный код нескольких разных, но связанных между собой проектов.

Это не просто один большой проект, а скорее папка, содержащая множество независимых проектов (например, веб-приложение, мобильное приложение и общая библиотека компонентов), которые живут и развиваются в рамках одного репозитория.

----
monorepo/
├── apps/              # Конечные приложения
│   ├── web-app/       # Исходники веб-приложения
│   └── mobile-app/    # Исходники мобильного приложения
├── packages/ (or libs/) # Переиспользуемые библиотеки
│   ├── ui-kit/        # Общие UI-компоненты
│   └── api-client/    # Клиент для работы с API
└── ...                # Общие файлы конфигурации
----

== Преимущества (Плюсы)

. *Упрощенное управление зависимостями.* Если `web-app` и `mobile-app` используют `ui-kit`, им не нужно ждать публикации новой версии библиотеки. Любое изменение в `ui-kit` становится мгновенно доступно всем потребителям.

. *Атомарные изменения.* Вы можете внести изменение в общую библиотеку и одновременно обновить все приложения, которые ее используют, в рамках одного коммита и одного Pull Request. Это гарантирует, что ничего не сломается.

. *Легкость переиспользования кода.* Общие компоненты, утилиты и типы легко выносить в общие библиотеки (`packages`) и использовать во всех проектах.

. *Централизованная сборка и CI/CD.* Вся логика сборки, тестирования и развертывания находится в одном месте, что упрощает управление.

. *Масштабный рефакторинг.* Легко найти все использования компонента или функции по всему коду и провести рефакторинг за один раз.

== Недостатки (Минусы)

. *Проблемы с производительностью Git.* С ростом количества проектов и истории коммитов репозиторий может стать очень большим. Команды `git clone`, `git fetch` и `git status` могут выполняться медленно.

. *Длительное время сборки.* Если не оптимизировать CI/CD, пайплайн будет пытаться собрать и протестировать *все* проекты при каждом изменении, даже если оно затронуло только один из них.

. *Сложность настройки CI/CD.* Пайплайны должны быть "умными" и определять, какие именно проекты были затронуты изменением, чтобы запускать задачи только для них.

. *Необходимость в специальных инструментах.* Стандартных средств Git и пакетных менеджеров часто недостаточно. Требуются специализированные инструменты для управления монорепозиториями:
* *Для JavaScript/TypeScript:* Lerna, Nx, Turborepo.
* *Для Java/Kotlin:* Gradle (с его многопроектной структурой).
* *Универсальные:* Bazel (от Google), Buck (от Meta).

== Как работать с монорепозиторием?

Работа в монорепозитории требует особого подхода к оптимизации.

=== 1. Оптимизация Git

Для борьбы с большим размером репозитория используются специальные возможности Git:

* *Частичное клонирование (Sparse Checkout):*
Позволяет скачать на локальную машину не весь репозиторий, а только нужные вам директории. Например, если вы работаете только над мобильным приложением.
+
[source,bash]
----
# Клонируем репозиторий без скачивания файлов
git clone --filter=blob:none --no-checkout <repo_url>
cd <repo_name>

# Указываем, какие папки нам нужны
git sparse-checkout set apps/mobile-app packages/ui-kit

# Скачиваем только нужные файлы
git checkout main
----

* *Поверхностное клонирование (Shallow Clone):*
Команда `git clone --depth 1` скачивает только последний коммит, что значительно ускоряет первоначальное клонирование.

=== 2. Оптимизация сборки и CI/CD

Это самая важная часть работы с монорепозиторием. Ключевая идея — **собирать и тестировать только то, что было затронуто изменениями**.

Инструменты вроде **Nx** и **Turborepo** делают это автоматически. Они строят граф зависимостей между проектами внутри репозитория и при каждом изменении вычисляют, какие проекты нужно пересобрать и протестировать.

Пример логики в CI/CD пайплайне:
. *Определить измененные файлы* в коммите (`git diff`).
. *Определить, к каким проектам* относятся эти файлы.
. *Определить, какие другие проекты* зависят от измененных.
. *Запустить задачи* (`build`, `test`) только для этого подмножества проектов.

Современные инструменты для монорепозиториев предоставляют для этого готовые команды, например:

[source,bash]
----
# Собрать только те приложения, которые были затронуты последними изменениями
npx nx affected --target=build

# Запустить тесты только для затронутых библиотек
npx nx affected --target=test
----

== Вывод

Монорепозиторий — это мощный инструмент для команд, работающих над несколькими тесно связанными проектами. Он значительно упрощает переиспользование кода и управление зависимостями, но требует более сложной настройки инструментов и CI/CD для эффективной работы.