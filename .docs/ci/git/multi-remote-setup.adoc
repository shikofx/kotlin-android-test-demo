= Настройка нескольких удаленных репозиториев (multi-remote)

Вести один проект в двух и более репозиториях — не только возможно, но и является распространенной практикой. Вы можете настроить ваш локальный Git-репозиторий так, чтобы он был связан сразу с несколькими удаленными репозиториями. Это позволяет, например, использовать GitHub как публичное зеркало, а GitLab — как основную площадку для CI/CD и внутренней разработки.

== Зачем это нужно?

*   *Резервное копирование:* Хранение кода на двух независимых платформах.
*   *Использование лучших функций:* Вы можете использовать GitHub Actions для публичного CI и GitLab CI для более сложных или приватных задач на своем сервере.
*   *Публичное/приватное зеркало:* Основная работа ведется в приватном репозитории (GitLab), а публичная версия для open-source сообщества находится на GitHub.

== Шаг 1: Просмотр текущих удаленных репозиториев

Сначала давайте посмотрим, какие удаленные репозитории уже настроены. Обычно после клонирования с GitHub у вас будет один репозиторий с именем `origin`.

[source,bash]
----
git remote -v
----

Вывод будет примерно таким:

[source,text]
----
origin  git@github.com:username/project-name.git (fetch)
origin  git@github.com:username/project-name.git (push)
----

== Шаг 2: Добавление второго удаленного репозитория (GitLab)

Теперь добавим ваш GitLab-репозиторий как второй "удаленный сервер". Дадим ему понятное имя, например, `gitlab`.

[source,bash]
----
git remote add gitlab git@gitlab.your_domain.xyz:username/project-name.git
----

Проверим еще раз:

[source,bash]
----
git remote -v
----

Теперь вы увидите оба репозитория:

[source,text]
----
gitlab  git@gitlab.your_domain.xyz:username/project-name.git (fetch)
gitlab  git@gitlab.your_domain.xyz:username/project-name.git (push)
origin  git@github.com:username/project-name.git (fetch)
origin  git@github.com:username/project-name.git (push)
----

== Шаг 3: Отправка изменений (Push)

Теперь у вас есть два варианта отправки изменений:

=== Вариант А: Отправлять в каждый репозиторий по отдельности

[source,bash]
----
# Отправляем ветку main на GitHub
git push origin main

# Отправляем ветку main на GitLab
git push gitlab main
----

=== Вариант Б: Настроить автоматическую отправку в оба репозитория (рекомендуется)

Вы можете изменить URL для `push` у вашего основного репозитория (`origin`), чтобы он включал в себя и GitLab.

[source,bash]
----
# Добавляем GitLab URL в список push-адресов для 'origin'
git remote set-url --add --push origin git@gitlab.your_domain.xyz:username/project-name.git
----

После этого команда `git push origin main` будет автоматически отправлять ваши коммиты *сразу и на GitHub, и на GitLab*. Это самый удобный способ поддерживать оба репозитория в синхронизированном состоянии.

== Шаг 4: Удаление связи с удаленным репозиторием

Если вам больше не нужен один из удаленных репозиториев или вы хотите отменить настройку с двойным `push`, это можно легко сделать.

=== Вариант А: Полное удаление remote-связи

Чтобы полностью удалить связь с репозиторием (например, с `gitlab`), используйте команду `git remote remove`:

[source,bash]
----
git remote remove gitlab
----
После этого `git remote -v` больше не будет показывать `gitlab` в списке.

=== Вариант Б: Удаление дополнительного push URL

Если вы настраивали автоматическую отправку в оба репозитория (как в шаге 3, вариант Б) и хотите это отменить, вам нужно удалить только дополнительный URL для `push`.

[source,bash]
----
# Удаляем URL GitLab из списка push-адресов для 'origin'
git remote set-url --delete --push origin git@gitlab.your_domain.xyz:username/project-name.git
----
После этого команда `git push origin main` снова будет отправлять изменения только на GitHub.

== Шаг 5: Проверка статуса синхронизации

Когда вы работаете с несколькими удаленными репозиториями, важно понимать, находятся ли они в одинаковом состоянии. Вот несколько команд, которые помогут это проверить.

. *Получение актуальной информации* +
Прежде чем проверять статус, всегда загружайте последние изменения со всех удаленных репозиториев. Эта команда не меняет ваш локальный код, а только обновляет информацию о состоянии веток на серверах.
+
[source,bash]
----
git fetch --all
----

. *Сравнение веток напрямую* +
Самый надежный способ — напрямую сравнить коммиты в одноименных ветках на разных `remotes` с помощью команды `git log`.
+
[source,bash]
----
# Показать коммиты, которые есть в GitLab, но еще не попали в GitHub
git log origin/main..gitlab/main

# Показать коммиты, которые есть в GitHub, но еще не попали в GitLab
git log gitlab/main..origin/main
----
* Если *обе команды ничего не выводят*, значит, ветки `main` на GitHub и GitLab полностью синхронизированы.
* Если одна из команд показывает список коммитов, значит, один репозиторий "опережает" другой.

. *Просмотр детальной информации о remote* +
Команда `git remote show` предоставляет подробную информацию о конкретном удаленном репозитории, включая состояние его веток.
+
[source,bash]
----
# Показать детальную информацию о remote с именем 'gitlab'
git remote show gitlab
----
Эта команда покажет, какие локальные ветки отслеживают удаленные, какие ветки на сервере "устарели" (`stale`) и другую полезную информацию для диагностики.