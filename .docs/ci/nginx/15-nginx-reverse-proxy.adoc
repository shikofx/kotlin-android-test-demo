= Урок 15: Настройка Nginx как обратного прокси и HTTPS для сервисов

В нашей текущей конфигурации контейнеры GitLab и MinIO напрямую "смотрят" в интернет через свои порты. Это создает проблему при получении SSL-сертификатов, так как порт 80 может быть занят только одним процессом.

Более правильный и масштабируемый подход — использовать **обратный прокси (reverse proxy)**. Мы установим Nginx на хост-машину, и он станет единой точкой входа для всего HTTP/HTTPS трафика.



== Время жизни кэша (Cache Lifetime)

Часто возникает вопрос: как долго хранится кэш и можно ли задать для него время жизни (TTL)?

Напрямую указать TTL в файле `.gitlab-ci.yml` **нельзя**. Управление жизненным циклом кэша происходит на уровне самого инстанса GitLab:

*   **Для GitLab.com (облачная версия):** Кэш автоматически удаляется через **7 дней**.
*   **Для Self-hosted GitLab (наш случай):** Время жизни кэша зависит от настроек администратора сервера. Обычно кэш хранится в S3-совместимом хранилище, где администратор может настроить правила автоматической очистки (например, удалять все кэши старше 30 дней).

=== Как GitLab понимает, что кэш устарел?

Для разработчика основной механизм управления актуальностью кэша — это `cache:key`.

Когда вы меняете файл, указанный в `key:files` (например, добавляете новую библиотеку в `build.gradle.kts`), GitLab генерирует **новый ключ**. Для этого нового ключа кэша еще не существует, поэтому Runner создает его заново.

Старый кэш при этом не удаляется немедленно, но становится "сиротой" — новые задачи его больше не используют. Он будет удален позже, в соответствии с политиками хранения на сервере.

**Вывод:** Вы не управляете временем жизни кэша, но вы управляете его **актуальностью** через `cache:key`. Это самый правильный и эффективный подход.

=== Ограничения и лучшие практики

GitLab CI позволяет указать **не более двух файлов** в секции `key:files`. В многомодульном проекте, где у каждого модуля есть свой `build.gradle.kts`, отследить их все невозможно.

Именно поэтому современный подход к разработке на Android предполагает использование централизованного каталога версий (`libs.versions.toml`). В таком случае, для отслеживания почти всех зависимостей проекта достаточно указать всего один этот файл, что идеально вписывается в ограничения GitLab CI.

== Управление временем жизни кэша на Self-hosted GitLab

Как было сказано ранее, на self-hosted инстансе время жизни кэша зависит от настроек администратора. Самый правильный и гибкий способ управлять этим — использовать внешнее S3-совместимое хранилище, такое как **MinIO**.

Процесс состоит из двух шагов:
. **Настроить GitLab** для использования MinIO в качестве хранилища для кэша.
. **Настроить в MinIO "политику жизненного цикла" (Lifecycle Policy)**, которая будет автоматически удалять старые файлы кэша.

Например, можно настроить правило, которое удаляет все объекты (кэши) в "корзине" (bucket) `gitlab-runner-cache`, которые старше 7 дней. Это дает полный контроль над хранением и предотвращает переполнение диска.

В нашей текущей конфигурации контейнеры GitLab и MinIO напрямую "смотрят" в интернет через свои порты. Это создает проблему при получении SSL-сертификатов, так как порт 80 может быть занят только одним процессом.

Более правильный и масштабируемый подход — использовать **обратный прокси (reverse proxy)**. Мы установим Nginx на хост-машину, и он станет единой точкой входа для всего HTTP/HTTPS трафика.

== Архитектура

. *Nginx* будет слушать внешние порты 80 и 443.
. Он будет обрабатывать SSL-сертификаты (терминировать SSL).
. В зависимости от домена в запросе (`gitlab.<...>` или `s3.<...>`), он будет перенаправлять трафик на соответствующий внутренний порт, где работает нужный сервис (GitLab или MinIO).
. Он будет работать в связке с `certbot` для автоматического получения и обновления сертификатов.

== Шаг 1: Установка Nginx и Certbot

. Установите необходимые пакеты:
+
[source,bash]
----
sudo apt update
sudo apt install nginx certbot python3-certbot-nginx -y
----

[TIP]
====
* `sudo apt update`: Обновляет список доступных пакетов из репозиториев.
* `sudo apt install ... -y`: Устанавливает указанные пакеты. Флаг `-y` автоматически отвечает "да" на все вопросы установщика.
** `nginx`: Сам веб-сервер, который будет работать как обратный прокси.
** `certbot`: Утилита для получения и обновления SSL-сертификатов.
** `python3-certbot-nginx`: Плагин, который позволяет `certbot` "общаться" с Nginx и автоматически изменять его конфигурацию для поддержки HTTPS.
====

== Шаг 2: Централизованное управление секретами

Поскольку и GitLab, и MinIO будут использовать одни и те же учетные данные, логично вынести их в одно общее место. Мы создадим один файл `/srv/.env`, который будет служить единым источником правды.

. Создайте общий файл для секретов в директории `/srv`:
+
[source,bash]
----
sudo nano /srv/.env
----
+
[TIP]
====
* `sudo` выполняет команду с правами суперпользователя (администратора), что необходимо для работы в системных директориях.
* `nano` — это простой и удобный консольный текстовый редактор.
* `/srv/.env` — путь к файлу, который мы создаем.
====

. Добавьте в него учетные данные для MinIO. Будем использовать переменные, которые ожидает сам MinIO (`MINIO_ROOT_USER` и `MINIO_ROOT_PASSWORD`).
+
[source,text]
----
MINIO_ROOT_USER=YOUR_MINIO_ROOT_USER
MINIO_ROOT_PASSWORD=YOUR_MINIO_ROOT_PASSWORD
----
+
Сохраните и закройте файл.

== Шаг 3: Установка и запуск MinIO

. Создайте директорию для данных MinIO:
+
[source,bash]
----
sudo mkdir -p /srv/minio/data
----
+
[TIP]
====
* `mkdir` (make directory) создает новую директорию.
* Флаг `-p` (parents) позволяет создавать вложенные директории (`/srv/minio/`), если они еще не существуют.
====

. Создайте файл `/srv/minio/docker-compose.yml`:
+
[source,bash]
----
sudo nano /srv/minio/docker-compose.yml
----

. Вставьте в него следующую конфигурацию, которая ссылается на наш центральный `.env` файл:
+
[source,yaml]
----
version: '3.6'
services:
  minio:
    image: minio/minio:latest
    container_name: minio
    restart: always
    env_file:
      - ../.env # Используем центральный файл с секретами
    ports:
      - "9000:9000" # API
      - "9002:9001" # Web UI <-- Порт изменен для работы за Nginx
    volumes:
      - /srv/minio/data:/data
    command: server /data --console-address ":9001"
----

== Шаг 4: "Скрытие" сервисов за внутренними портами

Нам нужно "спрятать" наши сервисы за Nginx, изменив порты, на которых они доступны снаружи.

. **Для GitLab:** Откройте `/srv/gitlab/docker-compose.yml` и измените порты `80` и `443` на внутренние, например, `8081` и `8444`.
+
[source,yaml]
----
# /srv/gitlab/docker-compose.yml
services:
  web:
    # ...
    ports:
      - '8081:80'    # <-- ИЗМЕНЕНО
      - '8444:443'   # <-- ИЗМЕНЕНО
      - '22:22'
      - '5050:5050'
----

. **Примените изменения:** Перезапустите оба сервиса, чтобы они начали слушать новые (внутренние) порты.
+
[source,bash]
----
cd /srv/gitlab && sudo docker compose up -d --force-recreate
cd /srv/minio && sudo docker compose up -d --force-recreate
----

[TIP]
====
* `cd /srv/gitlab && ...`: Команда `&&` позволяет выполнить вторую команду только в том случае, если первая (`cd`) завершилась успешно. Это гарантирует, что `docker compose` будет запущен в правильной директории.
* `sudo docker compose up -d --force-recreate`: Пересоздает и запускает контейнеры в фоновом режиме (`-d`). Флаг `--force-recreate` необходим, чтобы применить изменения в `ports`.
====

== Шаг 5: Настройка Nginx и получение SSL-сертификатов

Теперь мы настроим Nginx для каждого из наших доменов и автоматически получим для них SSL-сертификаты.

. **Создайте конфигурацию для GitLab:**
+
[source,bash]
----
sudo nano /etc/nginx/sites-available/gitlab.<ваш-домен>.xyz
----
+
[TIP]
====
* `/etc/nginx/sites-available/`: Стандартная директория в Nginx, где хранятся конфигурационные файлы для всех "потенциально доступных" сайтов. Мы создаем здесь новый файл для нашего домена GitLab.
====
+
Вставьте базовую конфигурацию, которая перенаправляет трафик на внутренний порт GitLab:
+
[source,nginx]
----
server {
    listen 80;
    server_name gitlab.<ваш-домен>.xyz;

    location / {
        proxy_pass http://localhost:8081;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
}
----

. **Создайте конфигурацию для MinIO:**
+
Аналогично создайте файл `/etc/nginx/sites-available/s3.<ваш-домен>.xyz` и укажите в нем порт MinIO:
+
[source,nginx]
----
server {
    listen 80;
    server_name s3.<ваш-домен>.xyz;

    location / {
        proxy_pass http://localhost:9002; # <-- Порт веб-интерфейса MinIO
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
}
----

. **Активируйте конфигурации и проверьте Nginx:**
+
[source,bash]
----
# Создаем символические ссылки, чтобы "включить" наши сайты
sudo ln -s /etc/nginx/sites-available/gitlab.<ваш-домен>.xyz /etc/nginx/sites-enabled/
sudo ln -s /etc/nginx/sites-available/s3.<ваш-домен>.xyz /etc/nginx/sites-enabled/

# Проверяем синтаксис конфигурации Nginx
sudo nginx -t
----
+
[TIP]
====
* `sudo ln -s [источник] [назначение]`: Создает символическую ссылку. Мы "активируем" наши сайты, создавая ссылки на их конфигурации в директории `/etc/nginx/sites-enabled/`. Nginx читает файлы только из этой папки.
* `sudo nginx -t`: Проверяет все конфигурационные файлы Nginx на наличие синтаксических ошибок. Эту команду **обязательно** нужно выполнять перед перезапуском Nginx, чтобы не "сломать" рабочий веб-сервер.
====
+
Если команда `nginx -t` вывела `syntax is ok` и `test is successful`, можно продолжать.

. **Запустите Certbot:**
+
Эта команда найдет ваши конфигурации, получит для них SSL-сертификаты и автоматически перенастроит Nginx для работы по HTTPS.
+
[source,bash]
----
sudo certbot --nginx -d gitlab.<ваш-домен>.xyz -d s3.<ваш-домен>.xyz
----
+
[TIP]
====
* `sudo certbot --nginx`: Запускает `certbot` с использованием плагина для Nginx. Он сам найдет нужные конфигурации.
* `-d gitlab... -d s3...`: Указывает, для каких доменов нужно получить сертификаты. Можно указать несколько доменов за один раз.
====
+
`certbot` задаст несколько вопросов (например, ваш email и согласие с условиями). В конце он спросит, нужно ли делать редирект с HTTP на HTTPS — выберите вариант `2` (Redirect).

== Шаг 6: Настройка Runner'а для работы с HTTPS-адресом MinIO

Теперь, когда MinIO доступен по безопасному адресу, нужно обновить конфигурацию GitLab Runner.

. **Откройте конфигурационный файл GitLab Runner'а:**
+
[source,bash]
----
sudo nano /srv/gitlab-runner/config/config.toml
----

. **Обновите адрес MinIO и флаг `Insecure`.**
+
[source,toml]
----
[[runners]]
  # ...
  [runners.cache]
    Type = "s3"
    Shared = true
    [runners.cache.s3]
      ServerAddress = "s3.<ваш-домен>.xyz" # <-- ИЗМЕНЕНО
      AccessKey = "YOUR_MINIO_ROOT_USER"
      SecretKey = "YOUR_MINIO_ROOT_PASSWORD"
      BucketName = "gitlab-runner-cache"
      Insecure = false # <-- ИЗМЕНЕНО на false для HTTPS
----
+
[WARNING]
====
Файл `config.toml` не умеет читать переменные из `.env` файлов. Вам нужно вставить сюда ваши реальные `AccessKey` и `SecretKey` из файла `/srv/.env`.
====

. **Перезапустите GitLab Runner**, чтобы он применил новую конфигурацию:
+
[source,bash]
----
cd /srv/gitlab-runner
sudo docker compose restart
----
+
[TIP]
====
* `sudo docker compose restart`: Эта команда безопасно перезапускает сервис Runner'а, чтобы он перечитал обновленный `config.toml`.
====

== Шаг 7: Настройка времени жизни кэша в MinIO

Это финальный шаг, который включает автоматическую очистку.

. Войдите в веб-интерфейс MinIO по адресу `https://s3.<ваш-домен>.xyz`.
. Создайте "корзину" (bucket) с именем `gitlab-runner-cache`.
. Перейдите в созданную корзину и слева выберите вкладку **"Object Lifecycle Management"**.
. Нажмите **"+ Create a new rule"**.
. Настройте правило:
+
* *Rule Status:* `Enabled`.
* *Rule Target:* Оставьте пустым, чтобы правило применялось ко всем объектам в корзине.
* *Expiration:* Поставьте галочку `Enable`.
* *Expire objects created ... days ago:* Введите желаемое количество дней, например, `7` или `30`.

. Нажмите **"Save"**.

== Шаг 8: Финальная проверка

После выполнения всех шагов:
* Ваш GitLab должен быть доступен по адресу `https://gitlab.<ваш-домен>.xyz`.
* Веб-интерфейс MinIO должен быть доступен по `https://s3.<ваш-домен>.xyz`.
* GitLab Runner должен успешно использовать S3-кэш для ускорения сборок.

Теперь ваша инфраструктура настроена по лучшим практикам: все сервисы работают за обратным прокси, защищены HTTPS, а получение сертификатов будет обновляться автоматически.
== Архитектура

. *Nginx* будет слушать внешние порты 80 и 443.
. Он будет обрабатывать SSL-сертификаты (терминировать SSL).
. В зависимости от домена в запросе (`gitlab.<...>` или `s3.<...>`), он будет перенаправлять трафик на соответствующий внутренний порт, где работает нужный сервис (GitLab или MinIO).
. Он будет работать в связке с `certbot` для автоматического получения и обновления сертификатов.

== Шаг 1: Установка Nginx и Certbot

. Установите необходимые пакеты:
+
[source,bash]
----
sudo apt update
sudo apt install nginx certbot python3-certbot-nginx -y
----

[TIP]
====
* `sudo apt update`: Обновляет список доступных пакетов из репозиториев.
* `sudo apt install ... -y`: Устанавливает указанные пакеты. Флаг `-y` автоматически отвечает "да" на все вопросы установщика.
** `nginx`: Сам веб-сервер, который будет работать как обратный прокси.
** `certbot`: Утилита для получения и обновления SSL-сертификатов.
** `python3-certbot-nginx`: Плагин, который позволяет `certbot` "общаться" с Nginx и автоматически изменять его конфигурацию для поддержки HTTPS.
====

== Шаг 2: "Скрытие" сервисов за внутренними портами

Нам нужно "спрятать" наши сервисы за Nginx, изменив порты, на которых они доступны снаружи.

. **Для GitLab:** Откройте `/srv/gitlab/docker-compose.yml` и измените порты `80` и `443` на внутренние, например, `8081` и `8444`.
+
[source,yaml]
----
# /srv/gitlab/docker-compose.yml
services:
  web:
    # ...
    environment:
      GITLAB_OMNIBUS_CONFIG: |
        external_url 'https://gitlab.<ваш-домен>.xyz'
        gitlab_rails['gitlab_shell_ssh_port'] = 2222
        # --- Настройки для обратного прокси (Nginx) ---
        nginx['enable'] = false
        gitlab_rails['trusted_proxies'] = ['127.0.0.1', '::1']
----
+
[source,yaml]
----
# /srv/gitlab/docker-compose.yml
services:
  web:
    # ...
    ports:
      - '8081:80'    # <-- ИЗМЕНЕНО
      - '8444:443'   # <-- ИЗМЕНЕНО
      - '2222:22'
      - '5050:5050'
----

. **Для MinIO:** Откройте `/srv/minio/docker-compose.yml` и измените порт веб-интерфейса `9001` на `9002`. Порт API `9000` можно оставить, так как он не конфликтует.
+
[source,yaml]
----
# /srv/minio/docker-compose.yml
services:
  minio:
    # ...
    ports:
      - "9000:9000" # API
      - "9002:9001" # Web UI <-- ИЗМЕНЕНО
----
+
[TIP]
====
**Зачем мы меняем порт `9001` на `9002`?**

Запись `9002:9001` означает: "связать порт **9002** хост-машины с портом **9001** внутри контейнера". Мы делаем это, чтобы "спрятать" прямой доступ к MinIO. Теперь Nginx будет принимать запросы на стандартный порт 443 (HTTPS) и перенаправлять их на внутренний порт `9002`, который слушает MinIO. Это и есть принцип работы обратного прокси.
====

. **Примените изменения:** Перезапустите оба сервиса, чтобы они начали слушать новые порты.
+
[source,bash]
----
cd /srv/gitlab && sudo docker compose up -d --force-recreate
cd /srv/minio && sudo docker compose up -d --force-recreate
----

[TIP]
====
* `cd /srv/gitlab && ...`: Команда `&&` позволяет выполнить вторую команду только в том случае, если первая (`cd`) завершилась успешно. Это гарантирует, что `docker compose` будет запущен в правильной директории.
* `sudo docker compose up -d --force-recreate`: Пересоздает и запускает контейнеры в фоновом режиме (`-d`). Флаг `--force-recreate` необходим, чтобы применить изменения в `ports`.
====

== Шаг 3: Настройка Nginx и получение SSL-сертификатов

Теперь мы настроим Nginx для каждого из наших доменов и автоматически получим для них SSL-сертификаты.

. **Создайте конфигурацию для GitLab:**
+
[source,bash]
----
sudo nano /etc/nginx/sites-available/gitlab.<ваш-домен>.xyz
----
+
[TIP]
====
* `/etc/nginx/sites-available/`: Стандартная директория в Nginx, где хранятся конфигурационные файлы для всех "потенциально доступных" сайтов. Мы создаем здесь новый файл для нашего домена GitLab.
====
+
Вставьте базовую конфигурацию, которая перенаправляет трафик на внутренний порт GitLab:
+
[source,nginx]
----
server {
    listen 80;
    server_name gitlab.<ваш-домен>.xyz;

    location / {
        proxy_pass http://localhost:8081;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
}
----

. **Создайте конфигурацию для MinIO:**
+
Аналогично создайте файл `/etc/nginx/sites-available/s3.<ваш-домен>.xyz` и укажите в нем порт MinIO:
+
[source,nginx]
----
server {
    listen 80;
    server_name s3.<ваш-домен>.xyz;

    location / {
        proxy_pass http://localhost:9002; # <-- Порт веб-интерфейса MinIO
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        # --- Дополнительные заголовки для S3-совместимых хранилищ ---
        proxy_set_header X-Forwarded-Host $host;
        proxy_set_header X-Forwarded-Port $server_port;
        proxy_set_header X-Amz-Content-Sha256 $http_x_amz_content_sha256;
        # ---------------------------------------------------------
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
}
----

. **Активируйте конфигурации и проверьте Nginx:**
+
[source,bash]
----
# Создаем символические ссылки, чтобы "включить" наши сайты
sudo ln -s /etc/nginx/sites-available/gitlab.<ваш-домен>.xyz /etc/nginx/sites-enabled/
sudo ln -s /etc/nginx/sites-available/s3.<ваш-домен>.xyz /etc/nginx/sites-enabled/

# Проверяем синтаксис конфигурации Nginx
sudo nginx -t
----
+
[TIP]
====
* `sudo ln -s [источник] [назначение]`: Создает символическую ссылку. Мы "активируем" наши сайты, создавая ссылки на их конфигурации в директории `/etc/nginx/sites-enabled/`. Nginx читает файлы только из этой папки.
* `sudo nginx -t`: Проверяет все конфигурационные файлы Nginx на наличие синтаксических ошибок. Эту команду **обязательно** нужно выполнять перед перезапуском Nginx, чтобы не "сломать" рабочий веб-сервер.
====
+
Если команда `nginx -t` вывела `syntax is ok` и `test is successful`, перезапустите Nginx, чтобы применить изменения:
+
[source,bash]
----
sudo systemctl restart nginx
----
+
[TIP]
====
**`restart` или `reload`?**
*   `reload` плавно перезагружает конфигурацию, не прерывая соединения. Он работает, только если Nginx *уже запущен*.
*   `restart` полностью останавливает и заново запускает сервис. Используйте эту команду, если вы не уверены в состоянии сервиса или если `reload` выдает ошибку `nginx.service is not active`.
====
+
Если команда `nginx -t` вывела `syntax is ok` и `test is successful`, можно продолжать.

. **Запустите Certbot:**
+
Эта команда найдет ваши конфигурации, получит для них SSL-сертификаты и автоматически перенастроит Nginx для работы по HTTPS.
+
[source,bash]
----
sudo certbot --nginx --redirect -d gitlab.<ваш-домен>.xyz -d s3.<ваш-домен>.xyz
----
+
[TIP]
====
* `sudo certbot --nginx`: Запускает `certbot` с использованием плагина для Nginx. Он сам найдет нужные конфигурации.
* `--redirect`: Явно указывает `certbot` настроить автоматическое перенаправление с HTTP на HTTPS.
* `-d gitlab... -d s3...`: Указывает, для каких доменов нужно получить сертификаты. Можно указать несколько доменов за один раз.
====
+
`certbot` задаст несколько вопросов (например, ваш email и согласие с условиями). Поскольку мы указали флаг `--redirect`, он не будет спрашивать о перенаправлении, а настроит его автоматически.

== Шаг 4: Настройка Runner'а для работы с HTTPS-адресом MinIO

Теперь, когда MinIO доступен по безопасному адресу, нужно обновить конфигурацию GitLab Runner.

. **Откройте конфигурационный файл GitLab Runner'а:**
+
[source,bash]
----
sudo nano /srv/gitlab-runner/config/config.toml
----

. **Обновите адрес MinIO и флаг `Insecure`.**
+
[source,toml]
----
[[runners]]
  # ...
  [runners.cache]
    Type = "s3"
    Shared = true
    [runners.cache.s3]
      ServerAddress = "s3.<ваш-домен>.xyz" # <-- ИЗМЕНЕНО
      AccessKey = "YOUR_MINIO_ROOT_USER"
      SecretKey = "YOUR_MINIO_ROOT_PASSWORD"
      BucketName = "gitlab-runner-cache"
      Insecure = false # <-- ИЗМЕНЕНО на false для HTTPS
----
+
[WARNING]
====
Файл `config.toml` не умеет читать переменные из `.env` файлов. Вам нужно вставить сюда ваши реальные `AccessKey` и `SecretKey` из файла `/srv/.env`.
====

. **Перезапустите GitLab Runner**, чтобы он применил новую конфигурацию:
+
[source,bash]
----
cd /srv/gitlab-runner
sudo docker compose restart
----
+
[TIP]
====
* `sudo docker compose restart`: Эта команда безопасно перезапускает сервис Runner'а, чтобы он перечитал обновленный `config.toml`.
====

== Шаг 5: Настройка времени жизни кэша в MinIO

Это финальный шаг, который включает автоматическую очистку.

. Войдите в веб-интерфейс MinIO по адресу `https://s3.<ваш-домен>.xyz`.
. Создайте "корзину" (bucket) с именем `gitlab-runner-cache`.
. Перейдите в созданную корзину и слева выберите вкладку **"Object Lifecycle Management"**.
. Нажмите **"+ Create a new rule"**.
. Настройте правило:
+
* *Rule Status:* `Enabled`.
* *Rule Target:* Оставьте пустым, чтобы правило применялось ко всем объектам в корзине.
* *Expiration:* Поставьте галочку `Enable`.
* *Expire objects created ... days ago:* Введите желаемое количество дней, например, `7` или `30`.

. Нажмите **"Save"**.

== Шаг 6: Финальная проверка

После выполнения всех шагов:
* Ваш GitLab должен быть доступен по адресу `https://gitlab.<ваш-домен>.xyz`.
* Веб-интерфейс MinIO должен быть доступен по `https://s3.<ваш-домен>.xyz`.
* GitLab Runner должен успешно использовать S3-кэш для ускорения сборок.

Теперь ваша инфраструктура настроена по лучшим практикам: все сервисы работают за обратным прокси, защищены HTTPS, а получение сертификатов будет обновляться автоматически.