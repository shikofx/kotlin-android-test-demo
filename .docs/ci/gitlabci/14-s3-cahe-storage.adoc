= Урок 14: Настройка централизованного S3-кэша (MinIO + Nginx)

В предыдущем уроке мы настроили локальное кэширование. Однако, если у вас несколько Runner'ов, они не могут обмениваться кэшем. Решение — использовать **централизованное хранилище кэша**.

В этом уроке мы настроим полный стек для этой задачи:

*   **MinIO**: Легковесное S3-совместимое хранилище, где будут лежать архивы с кэшем.
*   **Nginx**: Обратный прокси, который обеспечит безопасный HTTPS-доступ к MinIO по красивому домену.
*   **Certbot**: Утилита для автоматического получения SSL-сертификатов.

== Зачем это нужно?

*   **Общий кэш для всех Runner'ov:** Любой Runner, подключенный к вашему GitLab, сможет использовать один и тот же кэш.
*   **Ускорение "холодных" сборок:** Если один Runner уже собрал проект и сохранил кэш, другой Runner для новой ветки сможет сразу его скачать, а не собирать все с нуля.
*   **Надежность:** Кэш хранится в надежном месте, а не на временном диске Runner'а.
*   **Контроль над временем жизни кэша:** Мы сможем настроить автоматическое удаление старых кэшей.

== Архитектура

include::../nginx/intro-reverse-proxy.adoc[tag=main]

== Шаг 1: Установка Nginx и подготовка инфраструктуры

Первый шаг — установка и настройка Nginx. Для этого необходимо временно остановить сервисы, занимающие порты 80 и 443.

. **Остановите GitLab**, чтобы освободить порты 80 и 443 для Nginx.
+
[source,bash]
----
cd /srv/gitlab && sudo docker compose down
----

. **Проверьте, что контейнер GitLab остановлен.**
+
[source,bash]
----
sudo docker ps -a
----
+
В выводе вы должны увидеть, что статус контейнера `gitlab-web-1` изменился на `Exited`.

. **Убедитесь, что порты 80 и 443 действительно свободны.**
+
[source,bash]
----
sudo lsof -i :80
sudo lsof -i :443
----
+
Эти команды **не должны ничего выводить**. Если они возвращают пустой результат, значит порты свободны, и можно продолжать.

== Шаг 2: Централизованное управление секретами

Поскольку и GitLab, и MinIO будут использовать одни и те же учетные данные, логично вынести их в одно общее место. Мы создадим один файл `/srv/.env`, который будет служить единым источником правды.

. Создайте общий файл для секретов в директории `/srv`:

[source,bash]
----
sudo nano /srv/.env
----

[INFO]
====

*   `sudo` выполняет команду с правами суперпользователя (администратора), что необходимо для работы в системных директориях.
*   `nano` — это простой и удобный консольный текстовый редактор.
*   `/srv/.env` — путь к файлу, который мы создаем.

====

. Добавьте в него учетные данные для MinIO. Будем использовать переменные, которые ожидает сам MinIO (`MINIO_ROOT_USER` и `MINIO_ROOT_PASSWORD`).
+
[source,text]
----
MINIO_ROOT_USER=your_username (any you want)
MINIO_ROOT_PASSWORD=your_user_password (any you want)
----
+
Сохраните и закройте файл.
+
[INFO]
====

*Горячие клавиши в `nano`:*

* *Сохранить:* `Ctrl + O` (Windows/Linux) или `^O` (macOS).
* *Выйти:* `Ctrl + X` (Windows/Linux) или `^X` (macOS).

====

== Шаг 3: Установка и запуск MinIO

. Создайте директорию для данных MinIO:
+
[source,bash]
----
sudo mkdir -p /srv/minio/data
----
+
[INFO]
====

*   `mkdir` (make directory) создает новую директорию.
*   Флаг `-p` (parents) позволяет создавать вложенные директории (`/srv/minio/`), если они еще не существуют.

====

. Создайте файл `/srv/minio/docker-compose.yml`:
+
[source,bash]
----
sudo nano /srv/minio/docker-compose.yml
----

. Вставьте в него следующую конфигурацию, которая ссылается на наш центральный `.env` файл:
+
[source,yaml,subs="attributes,callouts"]
----
include::../minio/docker-compose.yml[]
----

. **Запустите MinIO в интерактивном режиме для проверки.**
+
Мы запустим его без флага `-d`, чтобы увидеть логи запуска в реальном времени.
+
[source,bash]
----
cd /srv/minio && sudo docker compose up
----
+
Если все настроено правильно, вы увидите в логах строки, подтверждающие успешный запуск:
+
[source,text]
----
MinIO API: http://<IP-адрес>:9000  http://127.0.0.1:9000
MinIO Console: http://<IP-адрес>:9000 http://127.0.0.1:9000
----
+
. **Остановите MinIO**, нажав в терминале `Ctrl + C`.

. **Запустите MinIO в фоновом режиме.**
+
Теперь, когда мы убедились, что сервис работает, запустим его в фоновом режиме (`-d`), чтобы он продолжал работать после закрытия терминала.
+
[source,bash]
----
cd /srv/minio && sudo docker compose up -d
----

== Шаг 4: Настройка Nginx и получение SSL-сертификатов

Теперь мы настроим Nginx для проксирования трафика на MinIO и автоматически получим для него SSL-сертификат.

. **Создайте конфигурацию для MinIO:**
+
[source,bash]
----
sudo nano /etc/nginx/sites-available/s3.<ваш-домен>.xyz
----
+
Вставьте конфигурацию, которая перенаправляет весь трафик на единый порт MinIO (`9000`), так как теперь MinIO сам обслуживает и API, и веб-интерфейс с этого порта:

[source,nginx]
----
include::../minio/minio-nginx-config.adoc[]
----

. **Активируйте конфигурацию сайта.**
+
Мы создаем символическую ссылку из директории `sites-available` в `sites-enabled`. Nginx читает конфигурации только из `sites-enabled`, поэтому этот шаг "включает" наш новый сайт.
+
[source,bash]
----
sudo ln -s /etc/nginx/sites-available/s3.<ваш-домен>.xyz /etc/nginx/sites-enabled/
----
+
[INFO]
====
*   `sudo`: Выполняет команду с правами администратора.
*   `ln -s [источник] [назначение]`: Команда `ln` (link) с флагом `-s` (symbolic) создает символическую ссылку (ярлык). Это стандартная практика в Nginx, позволяющая легко включать и отключать сайты, не удаляя сам файл конфигурации.
====

. **Проверьте синтаксис конфигурации Nginx.**
+
Это **обязательный** шаг перед перезапуском, чтобы убедиться, что в конфигурации нет ошибок.
+
[source,bash]
----
sudo nginx -t
----
+
[INFO]
====
*   `nginx -t`: Запускает Nginx в тестовом режиме. Он проверяет все файлы конфигурации на синтаксические ошибки, но не применяет их. Если вы видите `syntax is ok` и `test is successful`, значит все в порядке.
====

. **Запустите Certbot:**
+
Эта команда найдет вашу конфигурацию, получит для нее SSL-сертификат и автоматически перенастроит Nginx для работы по HTTPS.
+
[source,bash]
----
sudo certbot --nginx --redirect -d s3.<ваш-домен>.xyz
----

. **Перезагрузите Nginx**, чтобы применить все изменения, включая те, что внес Certbot.
+
[source,bash]
----
sudo systemctl reload nginx
----

== Шаг 5: Проверка MinIO и создание "корзины"

Если при попытке доступа к `https://s3.<ваш-домен>.xyz` вы получаете ошибку `502 Bad Gateway` или "Сайт не позволяет установить соединение", это означает, что Nginx не может связаться с MinIO.

=== Диагностика проблемы

. **Проверьте статус контейнера MinIO.**
+
[source,bash]
----
sudo docker ps -a
----
+
Убедитесь, что контейнер `minio` находится в статусе `Up ...`. Если он `Restarting` или `Exited`, переходите к следующему пункту.

. **Посмотрите логи контейнера MinIO.**
+
[source,bash]
----
sudo docker logs minio
----
+
В логах ищите сообщения `ERROR` или `FATAL`. Частые причины:
+
*   `ERROR Unable to use the drive /data: permission denied`: У Docker нет прав на запись в `/srv/minio/data`.
+
[source,bash]
----
sudo chown -R 1001:1001 /srv/minio/data
cd /srv/minio && sudo docker compose up -d --force-recreate
----
+
*   `ERROR MINIO_ROOT_USER and MINIO_ROOT_PASSWORD must be specified`: Проблема с файлом `/srv/.env`. Убедитесь, что он существует и содержит правильные переменные.
+
. **Проверьте лог ошибок Nginx.**
+
[source,bash]
----
sudo tail -f /var/log/nginx/error.log
----
+
Попробуйте открыть `https://s3.<ваш-домен>.xyz` в браузере и посмотрите, какие ошибки появляются в логе Nginx.

Теперь, когда Nginx настроен для проксирования трафика на MinIO, самое время проверить, что все работает, и выполнить первоначальную настройку самого хранилища.

. Войдите в веб-интерфейс MinIO по адресу `https://s3.<ваш-домен>.xyz`.
. Используйте логин и пароль, которые вы указали в файле `/srv/.env`.
. Создайте "корзину" (bucket) с именем `gitlab-runner-cache`.
. Перейдите в созданную корзину и слева выберите вкладку **"Object Lifecycle Management"**.
. Нажмите **"+ Create a new rule"** и настройте правило для автоматического удаления объектов старше, например, 7 дней.

== Шаг 6: Запуск GitLab и настройка Runner'а

Теперь, когда вся инфраструктура для кэша готова и проверена, можно запустить GitLab и настроить Runner для работы с новым S3-хранилищем.

. **Запустите GitLab.**
+
[source,bash]
----
# Запускаем GitLab в фоновом режиме
cd /srv/gitlab && sudo docker compose up -d
----

. **Настройте GitLab Runner.**
+
Откройте файл `/srv/gitlab-runner/config/config.toml` и добавьте секцию для S3-кэша.
+
[source,toml]
----
[[runners]]
  # ... (существующие параметры runner'а)
  [runners.cache]
    Type = "s3"
    Shared = true
    [runners.cache.s3]
      ServerAddress = "s3.<ваш-домен>.xyz"
      AccessKey = "YOUR_MINIO_ROOT_USER"
      SecretKey = "YOUR_MINIO_ROOT_PASSWORD"
      BucketName = "gitlab-runner-cache"
      Insecure = false
----
+
[WARNING]
====
Файл `config.toml` не умеет читать переменные из `.env` файлов. Вам нужно вставить сюда ваши реальные `AccessKey` и `SecretKey` из файла `/srv/.env`.
====

. **Перезапустите GitLab Runner**, чтобы он применил новую конфигурацию:
+
[source,bash]
----
cd /srv/gitlab-runner
sudo docker compose restart
----

== Шаг 7: Проверка работы

После выполнения всех шагов запустите пайплайн в GitLab. В логе задачи вы должны увидеть сообщения, подтверждающие загрузку и скачивание кэша с S3-сервера:

[source,text]
----
Uploading cache.zip to https://s3.<ваш-домен>.xyz/gitlab-runner-cache/...
...
Downloading cache.zip from https://s3.<ваш-домен>.xyz/gitlab-runner-cache/...
----

Это подтверждает, что централизованное S3-кэширование успешно настроено.
