= Урок 12: Создание первого пайплайна

Теперь, когда вся инфраструктура (GitLab, Runner, Container Registry) настроена, пришло время запустить наш первый CI/CD пайплайн. Для этого мы создадим и разберем базовый файл `.gitlab-ci.yml`.

Цель этого урока — понять синтаксис `.gitlab-ci.yml` и убедиться, что связка "GitLab <-> Runner" работает корректно.

== Основы синтаксиса `.gitlab-ci.yml`

Файл `.gitlab-ci.yml` — это YAML-файл в корне вашего репозитория, который описывает, что GitLab должен делать при каждом коммите или другом событии.

=== Ключевые понятия (Keywords)

. *`stages` (Этапы):*
+
Ключевое слово `stages` — это "скелет" вашего пайплайна. Оно объявляется в самом начале файла `.gitlab-ci.yml` и определяет общую последовательность выполнения задач.
+
Порядок, заданный в `stages`, работает следующим образом:
+
.. Все задачи (`jobs`), принадлежащие к первому этапу из списка, запускаются *параллельно*.
.. Следующий этап начнется только после того, как *все* задачи предыдущего этапа *успешно* завершатся.
.. Если хотя бы одна задача провалится, пайплайн останавливается.
+
Хотя GitLab может использовать список этапов по умолчанию (`[build, test, deploy]`), если вы не укажете `stages`, *настоятельно рекомендуется* всегда определять его явно. Это делает структуру пайплайна очевидной и позволяет избежать ошибок при добавлении собственных, нестандартных этапов (например, `analyze`).
+
[IMPORTANT]
====
`stages` лишь определяет порядок. Пайплайн не будет создан, если в файле не определена хотя бы одна задача (`job`).
====
+
.Пример:
[source,yaml]
----
stages:
  - build
  - test
  - deploy

# Эти две задачи запустятся одновременно
build_app:
  stage: build
  script: "echo 'Building app...'"

build_docs:
  stage: build
  script: "echo 'Building docs...'"

# Эти три задачи запустятся одновременно, после успешного завершения этапа 'build'
unit_tests:
  stage: test
  script: "echo 'Running unit tests...'"

integration_tests:
  stage: test
  script: "echo 'Running integration tests...'"

system_tests:
  stage: test
  script: "echo 'Running system tests...'"

# Эта задача запустится только после успеха всех задач из этапа 'test'
deploy_to_production:
  stage: deploy
  script: "echo 'Deploying to production...'"
----

. *`job` (Задача):*
+
* Это основная единица работы. Например, `compile_code`, `run_tests`.
* Имя задачи (`job_name`) может быть любым.
* Каждая задача выполняется Runner'ом и содержит набор инструкций.
+
Имя задачи — это ключ верхнего уровня в YAML-файле, который не является зарезервированным словом (`stages`, `default`, `image` и т.д.).
+
[source,yaml]
----
# 'build_job' и 'test_job' - это имена двух разных задач (jobs)
build_job:
  stage: build
  script:
    - echo "Building the project..."

test_job:
  stage: test
  script:
    - echo "Running tests..."
----

. *`stage`:*
+
* Этот ключ используется внутри задачи, чтобы указать, к какому этапу она принадлежит. Например: `stage: test`.

. *`script`:*
+
* Самая важная часть задачи. Это массив команд, которые Runner должен выполнить.
* Пример: `script: ["./gradlew build", "echo 'Build complete'"]`.

. *`image`:*
+
* Указывает Docker-образ, внутри которого будет выполняться задача. Это очень удобно, так как позволяет иметь готовое окружение (например, с Java и Android SDK).
** *Откуда берутся образы?*
*** *Docker Hub (по умолчанию):* Если вы указываете короткое имя, например `ubuntu:latest` или `docker:20.10`, Runner будет искать его в публичном реестре Docker Hub.
*** *Другие реестры (включая GitLab Container Registry):* Если вы указываете полный путь к образу, включая домен реестра (например, `$CI_REGISTRY_IMAGE/my-image:tag`), Runner скачает его оттуда.
** *Где можно указывать?*
*** *На верхнем уровне (глобально):* Образ будет использоваться для всех задач по умолчанию.
*** *Внутри блока `default`:* Работает так же, как и на верхнем уровне.
*** *Внутри конкретной задачи (`job`):* Переопределяет глобальный образ только для этой задачи.
+
* *А что если `image` не указан нигде?*
+
В этом случае Runner будет использовать образ, который был задан при его собственной настройке в файле `config.toml` (см. link:11-gitlab-runner-setup.adoc[Урок 11]). В нашем случае это `alpine:latest`. Это гарантирует, что у задачи всегда будет окружение для выполнения `script`-команд.
+
.Пример:
[source,yaml]
----
# Глобальный образ для всех задач
image: ruby:3.0

test_job_1:
  script: "ruby --version" # Будет выполняться в ruby:3.0

test_job_2:
  # Эта задача переопределяет глобальный образ
  image: node:18
  script: "node --version" # Будет выполняться в node:18
----

. *`tags`:*
+
* Позволяет выбрать, на каком Runner'е должна выполняться задача. Runner "подхватит" задачу, только если у него есть все указанные теги.
+
.Пример:
Предположим, у вас есть Runner, которому при регистрации вы присвоили два тега: `linux` и `docker`.
+
[source,yaml]
----
# Эта задача запустится, так как у Runner'а есть тег 'docker'
job_1:
  tags:
    - docker
  script: "echo 'This runs on any docker runner'"

# Эта задача тоже запустится, так как у Runner'а есть оба тега
job_2:
  tags:
    - linux
    - docker
  script: "echo 'This runs on a linux runner with docker'"

# А эта задача будет "висеть" в состоянии ожидания (pending),
# так как наш Runner не имеет тега 'production' и не может
# ее выполнить.
job_3:
  tags:
    - production
  script: "echo 'This should run only in production'"
----

. *`default`:*
+
* Секция `default` позволяет задать значения по умолчанию для большинства ключей, которые могут быть использованы в задаче (`job`). Это избавляет от необходимости повторять одинаковые параметры в каждой задаче.
* *Какие параметры можно использовать?* Почти все, что вы можете указать в `job`, например:
** `image`
** `tags`
** `before_script`
** `after_script`
** `cache`
** `artifacts`
** `retry`
** `timeout`
* Значения, указанные внутри конкретной задачи, *переопределяют* значения из `default`.
+
.Пример:
[source,yaml]
----
default:
  image: ruby:3.0
  retry: 1

job1:
  # Использует image: ruby:3.0 и retry: 1
  script: "echo 'Job 1'"

job2:
  image: node:18 # Переопределяет образ, но по-прежнему использует retry: 1
  script: "echo 'Job 2'"
----

== Наш первый проверочный пайплайн

Вот как выглядит наш первый, максимально простой `.gitlab-ci.yml`:

[source,yaml]
----
default:
  image: $CI_REGISTRY_IMAGE/android-builder:latest
  tags:
    - docker

stages:
  - check_pipeline

check_job:
  stage: check_pipeline
  script:
    - echo "Проверка пайплайна"
----

=== Пошаговый разбор

. *`default` (Настройки по умолчанию):*
+
* `image: $CI_REGISTRY_IMAGE/android-builder:latest`: Эта строка — приказ для Runner'а. Она говорит: "Для выполнения всех задач (если не указано иное) используй Docker-образ `android-builder:latest`, который мы ранее собрали и загрузили в наш GitLab Container Registry".
+
** `$CI_REGISTRY_IMAGE` — это предопределенная переменная GitLab, которая автоматически заменяется на путь к Registry вашего проекта (например, `gitlab.t366.xyz:5050/shikofx/kotlin-android-test-demo`).

* `tags: - docker`: Это фильтр. Он говорит: "Эту задачу может выполнить только тот Runner, у которого есть тег `docker`". Мы указывали этот тег при настройке Runner'а в link:11-gitlab-runner-setup.adoc[Уроке 11].

. *`stages` (Этапы):*
+
* Мы объявляем всего один этап с именем `check_pipeline`. Наш пайплайн будет очень коротким.

. *`check_job` (Задача для проверки):*
+
* `check_job:` — это имя нашей единственной задачи.
* `stage: check_pipeline`: Мы привязываем эту задачу к нашему этапу `check_pipeline`.
* `script: - echo "Проверка пайплайна"`: Это и есть полезная работа. Runner выполнит эту shell-команду внутри Docker-контейнера и просто выведет строку "Проверка пайплайна" в лог выполнения.

== Как это работает: полный цикл

. Вы отправляете (`git push`) этот файл в ваш GitLab-репозиторий.
. GitLab видит файл `.gitlab-ci.yml` и создает новый пайплайн.
. Он находит задачу `check_job` и начинает искать свободный Runner с тегом `docker`.
. Наш Runner на сервере "слышит" GitLab, принимает задачу и начинает работу.
. Поскольку у Runner'а `executor = "docker"`, он:
+
.. Скачивает образ `gitlab.t366.xyz:5050/shikofx/kotlin-android-test-demo/android-builder:latest`.
.. Запускает из этого образа новый контейнер.
.. Внутри этого контейнера выполняет команду `echo "Проверка пайплайна"`.

. Если все прошло успешно, вы увидите в интерфейсе GitLab (в разделе *Build -> Pipelines*) успешно завершенный пайплайн.

Успешное выполнение этого простого пайплайна — это важнейшая веха. Она подтверждает, что вся наша сложная инфраструктура настроена верно, и мы готовы переходить к добавлению реальных задач: статического анализа, тестов и сборки приложения.