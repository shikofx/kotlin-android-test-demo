= Урок 13: Кэширование зависимостей в GitLab CI

Один из самых эффективных способов ускорить CI/CD пайплайны — это кэширование. Вместо того чтобы скачивать одни и те же зависимости (например, библиотеки Gradle) при каждом запуске, мы можем сохранить их и переиспользовать.

== Зачем нужно кэширование?

*   *Скорость:* Значительно сокращает время выполнения задач, так как не нужно каждый раз скачивать сотни мегабайт зависимостей из интернета.
*   *Стабильность:* Снижает зависимость от внешних репозиториев (Maven Central, Google, etc.). Если репозиторий временно недоступен, сборка все равно может пройти, используя кэшированные данные.
*   *Экономия трафика:* Уменьшает объем данных, скачиваемых Runner'ом.

== Как работает кэширование в GitLab CI?

В GitLab CI кэширование настраивается с помощью ключевого слова `cache`. Оно может быть определено как глобально (в секции `default`), так и для конкретной задачи.

Рассмотрим конфигурацию из нашего файла `.gitlab-ci.yml`:

[source,yaml]
----
default:
  cache:
    key:
      files:
        - settings.gradle.kts
        - build.gradle.kts
      prefix: ${CI_COMMIT_REF_SLUG}
    paths:
      - .gradle/
      - ~/.gradle/caches/
    policy: pull-push
----

=== `key` (Ключ кэша)

`key` — это уникальный идентификатор для архива с кэшем. GitLab Runner использует этот ключ, чтобы найти нужный кэш.

*   `files`: Это самая важная часть. GitLab вычисляет хэш-сумму указанных файлов (максимум двух). Если содержимое хотя бы одного из них изменится (например, вы обновите версию библиотеки в `build.gradle.kts`), хэш изменится, и будет создан *новый кэш*. Старый кэш при этом останется, но для новых задач будет использоваться уже новый.
*   `prefix: ${CI_COMMIT_REF_SLUG}`: Это префикс, который добавляется к ключу. Мы используем предопределенную переменную GitLab `CI_COMMIT_REF_SLUG`, которая содержит имя текущей ветки в безопасном для URL формате. Это гарантирует, что кэш для ветки `feature/new-login` не будет пересекаться с кэшем для ветки `develop`.

В итоге, ключ выглядит примерно так: `my-feature-branch-a1b2c3d4...`

=== `paths` (Пути)

Здесь мы указываем, какие файлы и директории нужно сохранить в архив кэша. Для Gradle-проекта это в первую очередь:

*   `~/.gradle/caches/`: Глобальный кэш Gradle, где хранятся все скачанные библиотеки, плагины и другие артефакты.
*   `.gradle/`: Локальный кэш проекта, где хранится информация о зависимостях, результатах предыдущих сборок и сам Gradle Wrapper.

IMPORTANT: Пути, начинающиеся с `~/`, относятся к домашней директории пользователя *внутри Docker-контейнера*, в котором выполняется задача.

=== `policy` (Политика)

Политика определяет, как Runner будет работать с кэшем.

*   `pull-push` (по умолчанию):
** *В начале задачи (pull):* Runner скачивает архив кэша, если находит его по ключу.
** *В конце задачи (push):* Runner сравнивает содержимое `paths` с тем, что было в кэше. Если появились новые файлы, он создает новый архив и загружает его в GitLab.

*   `pull`: Runner только скачивает кэш, но никогда не обновляет его. Полезно для задач, которые только потребляют зависимости, но не меняют их (например, задача развертывания).

*   `push`: Runner только загружает кэш, но никогда не скачивает его. Используется редко, например, в специальной задаче, которая только подготавливает кэш для других.

== Что происходит на практике?

. *Первый запуск пайплайна (для новой ветки):*
.. Runner не находит кэш по сгенерированному ключу.
.. Задача выполняется "с нуля", скачивая все зависимости Gradle.
.. В конце задачи Runner создает архив из директорий, указанных в `paths`, и загружает его в GitLab с уникальным ключом.

. *Последующие запуски (в той же ветке, без изменения `*.kts` файлов):*
.. Runner находит кэш по тому же ключу.
.. Он скачивает и распаковывает архив *перед* выполнением `script`.
.. Сборка Gradle начинается почти мгновенно, так как все зависимости уже на месте.

Это простое, но мощное изменение позволяет сократить время выполнения пайплайна в несколько раз.

== Время жизни кэша (Cache Lifetime)

Часто возникает вопрос: как долго хранится кэш и можно ли задать для него время жизни (TTL)?

Напрямую указать TTL в файле `.gitlab-ci.yml` **нельзя**. Управление жизненным циклом кэша происходит на уровне самого инстанса GitLab:

*   **Для GitLab.com (облачная версия):** Кэш автоматически удаляется через **7 дней**.
*   **Для Self-hosted GitLab (наш случай):** Время жизни кэша зависит от настроек администратора сервера. Обычно кэш хранится в S3-совместимом хранилище, где администратор может настроить правила автоматической очистки (например, удалять все кэши старше 30 дней).

=== Как GitLab понимает, что кэш устарел?

Для разработчика основной механизм управления актуальностью кэша — это `cache:key`.

Когда вы меняете файл, указанный в `key:files` (например, добавляете новую библиотеку в `build.gradle.kts`), GitLab генерирует **новый ключ**. Для этого нового ключа кэша еще не существует, поэтому Runner создает его заново.

Старый кэш при этом не удаляется немедленно, но становится "сиротой" — новые задачи его больше не используют. Он будет удален позже, в соответствии с политиками хранения на сервере.

**Вывод:** Вы не управляете временем жизни кэша, но вы управляете его **актуальностью** через `cache:key`. Это самый правильный и эффективный подход.

=== Ограничения и лучшие практики

Как вы правильно заметили, GitLab CI позволяет указать **не более двух файлов** в секции `key:files`. В многомодульном проекте, где у каждого модуля есть свой `build.gradle.kts`, отследить их все невозможно.

Именно поэтому современный подход к разработке на Android предполагает использование централизованного каталога версий (`libs.versions.toml`). В таком случае, для отслеживания почти всех зависимостей проекта достаточно указать всего один этот файл, что идеально вписывается в ограничения GitLab CI.

== Управление временем жизни кэша на Self-hosted GitLab

Как было сказано ранее, на self-hosted инстансе время жизни кэша зависит от настроек администратора. Самый правильный и гибкий способ управлять этим — использовать внешнее S3-совместимое хранилище, такое как **MinIO**.

Процесс состоит из двух шагов:
. **Настроить GitLab** для использования MinIO в качестве хранилища для кэша.
. **Настроить в MinIO "политику жизненного цикла" (Lifecycle Policy)**, которая будет автоматически удалять старые файлы кэша.

Например, можно настроить правило, которое удаляет все объекты (кэши) в "корзине" (bucket) `gitlab-runner-cache`, которые старше 7 дней. Это дает полный контроль над хранением и предотвращает переполнение диска.
