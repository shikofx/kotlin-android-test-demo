= Урок 13: Кэширование зависимостей в GitLab CI

Один из самых эффективных способов ускорить CI/CD пайплайны — это кэширование. Вместо того чтобы скачивать одни и те же зависимости (например, библиотеки Gradle) при каждом запуске, мы можем сохранить их и переиспользовать.

== Зачем нужно кэширование?

*   *Скорость:* Значительно сокращает время выполнения задач, так как не нужно каждый раз скачивать сотни мегабайт зависимостей из интернета.
*   *Стабильность:* Снижает зависимость от внешних репозиториев (Maven Central, Google, etc.). Если репозиторий временно недоступен, сборка все равно может пройти, используя кэшированные данные.
*   *Экономия трафика:* Уменьшает объем данных, скачиваемых Runner'ом.

== Как работает кэширование в GitLab CI?

В GitLab CI кэширование настраивается с помощью ключевого слова `cache`. Оно может быть определено как глобально (в секции `default`), так и для конкретной задачи.

Рассмотрим конфигурацию из нашего файла `.gitlab-ci.yml`:

[source,yaml]
----
default:
  cache:
    key:
      files:
        - gradle/wrapper/gradle-wrapper.properties
        - build.gradle
      prefix: ${CI_COMMIT_REF_SLUG}
    paths:
      - .gradle/
      - ~/.gradle/caches/
    policy: pull-push
----

=== `key` (Ключ кэша)

`key` — это уникальный идентификатор для архива с кэшем. GitLab Runner использует этот ключ, чтобы найти нужный кэш.

*   `files`: Это самая важная часть. GitLab вычисляет хэш-сумму указанных файлов (максимум двух). Если содержимое хотя бы одного из них изменится (например, вы обновите версию библиотеки в `build.gradle`), хэш изменится, и будет создан *новый кэш*. Старый кэш при этом останется, но для новых задач будет использоваться уже новый.
*   `prefix: ${CI_COMMIT_REF_SLUG}`: Это префикс, который добавляется к ключу. Мы используем предопределенную переменную GitLab `CI_COMMIT_REF_SLUG`, которая содержит имя текущей ветки в безопасном для URL формате. Это гарантирует, что кэш для ветки `feature/new-login` не будет пересекаться с кэшем для ветки `develop`.

В итоге, ключ выглядит примерно так: `my-feature-branch-a1b2c3d4...`

=== `paths` (Пути)

Здесь мы указываем, какие файлы и директории нужно сохранить в архив кэша. Для Gradle-проекта это в первую очередь:

*   `~/.gradle/caches/`: Глобальный кэш Gradle, где хранятся все скачанные библиотеки, плагины и другие артефакты.
*   `.gradle/`: Локальный кэш проекта, где хранится информация о зависимостях, результатах предыдущих сборок и сам Gradle Wrapper.

IMPORTANT: Пути, начинающиеся с `~/`, относятся к домашней директории пользователя *внутри Docker-контейнера*, в котором выполняется задача.

=== `policy` (Политика)

Политика определяет, как Runner будет работать с кэшем.

*   `pull-push` (по умолчанию):
** *В начале задачи (pull):* Runner скачивает архив кэша, если находит его по ключу.
** *В конце задачи (push):* Runner сравнивает содержимое `paths` с тем, что было в кэше. Если появились новые файлы, он создает новый архив и загружает его в GitLab.

*   `pull`: Runner только скачивает кэш, но никогда не обновляет его. Полезно для задач, которые только потребляют зависимости, но не меняют их (например, задача развертывания).

*   `push`: Runner только загружает кэш, но никогда не скачивает его. Используется редко, например, в специальной задаче, которая только подготавливает кэш для других.

== Что происходит на практике?

. *Первый запуск пайплайна (для новой ветки):*
.. Runner не находит кэш по сгенерированному ключу.
.. Задача выполняется "с нуля", скачивая все зависимости Gradle.
.. В конце задачи Runner создает архив из директорий, указанных в `paths`, и загружает его в GitLab с уникальным ключом.

. *Последующие запуски (в той же ветке, без изменения `*.gradle` файлов):*
.. Runner находит кэш по тому же ключу.
.. Он скачивает и распаковывает архив *перед* выполнением `script`.
.. Сборка Gradle начинается почти мгновенно, так как все зависимости уже на месте.

Это простое, но мощное изменение позволяет сократить время выполнения пайплайна в несколько раз.

== Шаг проверки: как убедиться, что кэш работает?

Самый надежный способ проверить работу кэша — посмотреть логи выполнения задачи в GitLab.

. **Запустите пайплайн первый раз** (например, сделав коммит).
+
В логе одной из задач (например, `pmd`) вы увидите сообщение о том, что кэш не найден, и Runner будет его создавать:
+
[source,text]
----
Creating cache <имя-ветки>-...-non_protected...
.gradle/: found 146 matching files and directories
~/.gradle/caches/: found 382 matching files and directories
No URL provided, cache will be not uploaded to shared cache server. Cache will be stored only locally.
Created cache
----

. **Запустите пайплайн второй раз** (нажав "Run pipeline" в интерфейсе GitLab, не меняя код).
+
Теперь в логе той же задачи вы увидите, что Runner успешно нашел и скачал кэш:
+
[source,text]
----
Restoring cache...
Downloading cache.zip from http://<runner-ip>/...
Successfully extracted cache
----
+
Кроме того, вы заметите, что задача выполнилась значительно быстрее, так как Gradle не скачивал зависимости заново. Это и есть прямое доказательство того, что кэширование настроено правильно и работает.
