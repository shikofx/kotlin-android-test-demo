= Решение проблемы "Address already in use" (Порт уже занят)

Это одна из самых частых ошибок при настройке веб-серверов и обратных прокси. Она означает, что процесс (например, Nginx) не может запуститься, потому что сетевой порт, который он пытается использовать (обычно `80` или `443`), уже занят другим процессом.

== Диагностика: как найти "захватчика"

Чтобы понять, какой именно процесс занял порт, можно использовать одну из двух команд.

=== Способ 1: `lsof` (List Open Files)

Это самый прямой способ. Команда показывает, какой процесс слушает конкретный порт.

[source,bash]
----
# Посмотреть, что заняло порт 80
sudo lsof -i :80

# Посмотреть, что заняло порт 443
sudo lsof -i :443
----

*Пример вывода:*
[source,text]
----
COMMAND     PID   USER   FD   TYPE DEVICE SIZE/OFF NODE NAME
docker-pr 54321   root    4u  IPv6 532958      0t0  TCP *:http (LISTEN)
----

Здесь `COMMAND` (`docker-proxy`) — это и есть тот процесс, который занял порт. Это **неправильное состояние**, если вы настраиваете Nginx.

*Пример правильного вывода (после исправления):*
[source,text]
----
COMMAND    PID   USER   FD   TYPE  DEVICE SIZE/OFF NODE NAME
nginx   281162   root    5u  IPv4 1465696      0t0  TCP *:http (LISTEN)
nginx   281162   root    9u  IPv4 1467600      0t0  TCP *:https (LISTEN)
----

Этот вывод показывает, что порты `http` (80) и `https` (443) теперь слушает `nginx`, что является **правильным состоянием** для архитектуры с обратным прокси.

=== Способ 2: `netstat`

== Как проверить, что Nginx работает?

После того как вы запустили Nginx, есть несколько способов убедиться, что он работает корректно.

=== 1. Проверка статуса сервиса

Самый надежный способ — проверить статус системной службы `nginx`.

[source,bash]
----
sudo systemctl status nginx.service
----

Если все в порядке, вы увидите зеленую надпись `active (running)`.

=== 2. Проверка портов

Убедитесь, что Nginx слушает порты 80 и 443, а не какой-либо другой процесс.

[source,bash]
----
sudo lsof -i :80
----

В выводе в колонке `COMMAND` должно быть `nginx`.

Эта команда показывает все активные сетевые подключения. Ее вывод можно отфильтровать.

[source,bash]
----
# Показать все слушающие TCP/UDP порты и найти строки с :80 или :443
sudo netstat -tulpn | grep -E ':80|:443'
----

* `-tulpn`: набор флагов (`tcp`, `udp`, `listening`, `programs`, `numeric`).
* `| grep -E ':80|:443'`: фильтрует вывод, оставляя только строки с нужными портами.

== Решение

После того как вы определили, какой процесс занимает порт (в нашем случае это почти всегда `docker-proxy` от GitLab или другого сервиса), решение состоит из следующих шагов:

. **Остановить конфликтующий сервис.** Например, если порт занят GitLab'ом:
+
[source,bash]
----
cd /srv/gitlab && sudo docker compose down
----

. **Изменить конфигурацию** конфликтующего сервиса так, чтобы он использовал другие, внутренние порты (например, `8081` вместо `80`), как это описано в уроке про настройку обратного прокси.

. **Запустить Nginx**, который теперь сможет занять освободившиеся порты `80` и `443`.

. **Снова запустить** ранее остановленный сервис. Теперь он будет работать "за" Nginx.