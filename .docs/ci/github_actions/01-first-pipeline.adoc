= Урок 1: "Hello, World!" — Создание первого пайплайна

**Цель:** Понять базовую структуру workflow в GitHub Actions. Мы создадим простейший пайплайн, который будет запускаться автоматически, скачивать код вашего проекта и выполнять простую команду.

== Ключевые концепции

* *Workflow (рабочий процесс):* Автоматизированный процесс, который вы описываете в `.yml` файле.
* *Event (событие):* Триггер, который запускает ваш workflow. Самый частый — `push` в репозиторий.
* *Job (задание):* Набор шагов, который выполняется на одном виртуальном сервере (runner).
* *Step (шаг):* Отдельная задача, которая может быть либо командой (`run`), либо готовым действием (`uses`).
* *Action (действие):* Готовый, переиспользуемый блок для выполнения сложных задач (например, скачивание кода или настройка Java).
* *Runner (исполнитель):* Виртуальный сервер (Linux, Windows или macOS), на котором выполняются ваши задания.

---

== Шаг 1: Создание файла Workflow

В корне вашего репозитория создайте директорию `.github`, а внутри нее — директорию `workflows`. Внутри `workflows` создайте файл с именем `android-ci.yml`.

Структура будет такой:
[source,text]
----
your-project-root/
├── .github/
│   └── workflows/
│       └── android-ci.yml
└── ...
----

== Шаг 2: Добавление базового кода

Вставьте в файл `android-ci.yml` следующий код.

[source,yaml,subs="callouts"]
----
name: Android CI/CD Pipeline <1>
on: <2>
  # Запускать при push в любую ветку
  push:
    branches: [ '**' ] <3>
  # Запускать при создании Pull Request в ветку `main`
  pull_request:
    branches: [ main ] <4>

jobs: <5>
  build:
    name: Build Project <6>
    runs-on: ubuntu-latest <7>

    steps: <8>
      - name: Checkout code
        uses: actions/checkout@v4 <9>

      - name: List files in repository
        run: ls -la <10>
----
<1> `name` — имя всего пайплайна.
<2> `on` — блок, определяющий события-триггеры.
<3> `push` с `branches: [ '**' ]` означает, что пайплайн будет запускаться при push в *любую* ветку. `**` — это специальный шаблон, соответствующий любому имени.
<4> `pull_request` с `branches: [ main ]` означает, что пайплайн будет запускаться только при создании или обновлении Pull Request, целью которого является ветка `main`.
<5> `jobs` — блок, содержащий одно или несколько заданий.
<6> `name` (внутри `build`) — имя конкретного задания, которое будет видно в UI.
<7> `runs-on` — тип виртуальной машины (раннера), на которой будет выполняться задание.
<8> `steps` — последовательность шагов внутри задания.
<9> `uses` — указывает на использование готового действия (action). `actions/checkout` — стандартное действие для клонирования репозитория.
<10> `run` — выполняет команду в командной строке раннера.

=== Детальный разбор: `on`

Ключевое слово `on` определяет, какие **события (events)** будут запускать ваш пайплайн. GitHub предоставляет огромный выбор триггеров, что позволяет создавать очень гибкие автоматизации.

Рассмотрим самые популярные из них:

*`push`*::
Запускает пайплайн, когда кто-то отправляет коммиты в репозиторий.
[source,yaml]
----
on:
  push:
    branches: # Запускать только для определенных веток
      - main
      - 'feature/**' # Все ветки, начинающиеся с 'feature/'
    paths: # Запускать, только если изменены файлы в этих путях
      - 'src/**'
----

*`pull_request`*::
Запускает пайплайн при создании или обновлении Pull Request. Идеально для проверок кода перед слиянием.
[source,yaml]
----
on:
  pull_request:
    types: [opened, synchronize, reopened] # Типы событий PR
    branches: [ main ] # Только для PR в ветку main
----

*`workflow_dispatch`*::
Позволяет запускать пайплайн **вручную** через интерфейс GitHub на вкладке "Actions". Очень удобно для задач, которые не нужно выполнять при каждом коммите (например, сборка релизной версии).

=== Детальный разбор: `actions/checkout@v4`

Это одна из самых фундаментальных и важных частей любого пайплайна. Давайте разберем строку `uses: actions/checkout@v4` по частям:

* *`uses:`* -- это ключевое слово, которое говорит: "используй готовое действие (action)". Вместо того чтобы писать все команды с нуля (например, `git clone ...`), мы используем уже готовый, протестированный и поддерживаемый блок кода.

* *`actions/checkout`* -- это имя самого действия.
** `actions` -- это название *организации* на GitHub, принадлежащей самой компании GitHub. В этой организации команда GitHub разрабатывает и поддерживает набор "официальных", базовых действий. Думайте об этом как о стандартной библиотеке для Actions.
** `checkout` -- это название конкретного action. Его главная задача -- **скачать (клонировать) код вашего репозитория** на виртуальную машину (runner), на которой выполняется ваш пайплайн. Без этого шага у виртуальной машины не будет доступа к вашим файлам (`gradlew`, `build.gradle` и т.д.), и она ничего не сможет собрать.

* *`@v4`* -- это **версия** действия. Это работает так же, как указание версии библиотеки в `build.gradle`.
** Использование конкретной версии (например, `@v4` или `@v4.1.1`) -- это лучшая практика. Она гарантирует, что ваш пайплайн будет работать стабильно и предсказуемо, даже если разработчики action выпустят новую, обратно несовместимую версию (`v5`).
** `v4` -- это "плавающий" тег, который указывает на последнюю стабильную версию в рамках 4-й мажорной ветки.

*Итог:* Строка `uses: actions/checkout@v4` -- это надежный и стандартный способ сказать GitHub Actions: "Первым делом, пожалуйста, скачай код моего проекта на машину, где будет происходить сборка".

=== Детальный разбор: `runs-on: ubuntu-latest`

Это один из ключевых параметров в любом задании (`job`). Он указывает, на какой виртуальной машине будет выполняться ваше задание. Эти машины называются **раннерами (runners)**.

GitHub предоставляет два основных типа раннеров:

. *GitHub-hosted runners (Раннеры, предоставляемые GitHub):* Это стандартные, готовые к использованию виртуальные машины, которые GitHub создает для вас автоматически.
. *Self-hosted runners (Собственные раннеры):* Это ваши собственные машины (физические серверы, облачные инстансы), которые вы можете подключить к GitHub Actions.

==== Раннеры, предоставляемые GitHub

Это самый простой и распространенный вариант. Вы просто указываете метку (label) операционной системы.

*`ubuntu-latest`*::
Это специальная метка, которая всегда указывает на последнюю стабильную версию Ubuntu, поддерживаемую GitHub (на данный момент это *Ubuntu 22.04*). Это стандартный выбор для большинства проектов, так как Linux-раннеры быстрые и универсальные.

*Другие варианты:*

* *Windows:*
** `windows-latest` (сейчас это Windows Server 2022)
** `windows-2022`

* *macOS:*
** `macos-latest` (сейчас это macOS 13)
** `macos-14` (Sonoma, процессор Apple Silicon)
** `macos-13` (Ventura, процессор Intel)
** _Примечание:_ Раннеры macOS значительно дороже и потребляют больше бесплатных минут. Они необходимы, если вы собираете приложения под iOS или macOS.

* *Linux (Ubuntu):*
** `ubuntu-22.04` (рекомендуется для стабильности, чтобы избежать сюрпризов при обновлении `latest`)
** `ubuntu-20.04`

==== Собственные раннеры (Self-hosted)

Вы можете настроить свои собственные машины в качестве раннеров. Это дает полный контроль над окружением, железом и установленным ПО.

В этом случае вы присваиваете своим раннерам метки (например, `self-hosted`, `linux`, `x64`) и используете их в `runs-on`:
[source,yaml]
----
runs-on: [self-hosted, linux]
----

---

== Шаг 3: Что делать дальше?

. Создайте файл `.github/workflows/android-ci.yml` с этим содержимым.
. Сделайте коммит и отправьте (`push`) изменения в ваш репозиторий на GitHub.
. Перейдите в вашем репозитории на вкладку **Actions**. Вы увидите, как ваш новый пайплайн запустился и начал выполняться. Кликните на него, чтобы посмотреть детали и логи выполнения. В логах шага "List files in repository" вы должны увидеть список файлов вашего проекта.

Это и есть основа. В следующем уроке мы заменим команду `ls -la` на реальные шаги, необходимые для сборки Android-приложения.