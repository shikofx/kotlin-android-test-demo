= Структура CI/CD пайплайна

**Цель:** Реструктурировать CI/CD пайплайн для повышения эффективности, логической последовательности и экономии ресурсов.

== 1. Проблема

Изначально все задачи (анализ, тесты, сборка) выполнялись в одной большой джобе (`build_and_analyze`). Это приводило к двум проблемам:

. **Неэффективное использование времени:** Независимые задачи, такие как статический анализ, не могли выполняться параллельно, что замедляло получение обратной связи.
. **Неэффективное использование ресурсов:** Тесты запускались даже в том случае, если код не проходил базовые проверки статического анализа, что приводило к лишним тратам минут GitHub Actions.

== 2. Решение: разделение на логические этапы

Пайплайн был полностью переработан и разделен на несколько последовательных этапов (`jobs`), внутри которых задачи могут выполняться параллельно.

Новая структура CI/CD выглядит так:

[mermaid]
....
graph TD
    subgraph "Этап 1: Статический анализ (параллельно)"
        A[checkstyle]
        B[pmd]
        C[lint]
    end

    subgraph "Этап 2: Тестирование"
        D[testing]
    end

    subgraph "Этап 3: Финальные шаги (параллельно)"
        E[build_apks]
        F[publish_reports]
    end

    subgraph "Этап 4: Развертывание отчета"
        G[deploy_report]
    end

    A --> D
    B --> D
    C --> D

    D --> E
    D --> F

    E --> G
    F --> G
....

. **Этап 1: Статический анализ.** Три задачи (`checkstyle`, `pmd`, `lint`) запускаются параллельно. Каждая выполняет свой тип анализа и выгружает отчет в виде артефакта.

. **Этап 2: Тестирование.** Задача `testing` запускается только *после успешного завершения всех задач анализа*. Это экономит ресурсы, как и планировалось. На данном этапе она выполняет только Unit-тесты. Отчет о них также выгружается как артефакт.

. **Этап 3: Финальные шаги.** После успешного прохождения тестов параллельно запускаются две задачи:
    *   `build_apks`: Собирает debug и/или release APK.
    *   `publish_reports`: Запускается всегда (`if: always()`), чтобы собрать отчеты даже с упавших проверок. Она скачивает все артефакты (отчеты Checkstyle, PMD, Lint, Unit-тестов, а также `lint-baseline.xml`) и собирает из них единую страницу для GitHub Pages. Эта задача полностью самодостаточна и не требует скачивания исходного кода.

. **Этап 4: Развертывание отчета.** Финальная задача `deploy_report` ждет завершения и сборки APK, и подготовки отчетов, после чего публикует сайт на GitHub Pages.

== 3. Преимущества новой структуры

*   **Эффективность:** Независимые задачи анализа выполняются параллельно, сокращая общее время ожидания.
*   **Экономия ресурсов:** Тесты не запускаются, если код не прошел статический анализ.
*   **Надежность:** Отчеты собираются и публикуются даже в случае падения одной из проверок.
*   **Читаемость:** Пайплайн разделен на четкие, логичные этапы, что упрощает его понимание и поддержку.

== 4. Примечание о настройке параллельных задач

Каждая задача (`job`) в GitHub Actions запускается в своей собственной, изолированной виртуальной среде. По этой причине шаги по подготовке окружения (клонирование кода, установка JDK, предоставление прав `gradlew`) необходимо повторять в каждой параллельной задаче.

При этом **кэш Gradle** является общим для всего воркфлоу. Первая завершившаяся задача создаст кэш, а все остальные смогут его переиспользовать, что по-прежнему обеспечивает значительное ускорение сборок за счет экономии времени на скачивании зависимостей.